# -*- coding: utf-8 -*-
"""
Created on Thu Mar 20 02:08:01 2025

@author: siddh
"""

def main():
    pass

if __name__ == '__main__':
    main()


import os
import math
import time
import datetime
import sys, getopt
import pychrono as chrono
import pychrono.postprocess as postprocess
import pychrono.irrlicht as irr
import pytz
import csv
import logging

import matplotlib.pyplot as plt
import numpy as np
from numpy import linalg as LA
import scipy
from scipy import linalg

from package1.gains import Gains
from package1.functions import *
from package1.trajectory_functions import *
from package1.trajectory import *
from package1.controller.PID.pid import PID_controller
from package1.Pid_function import rk4
from package1.odeinput import ode_inputs
from package1.flight_params import flight_params

PI = math.pi

#Instances
flight_params_instance=flight_params()
gains_instance=Gains()

roll, pitch, yaw = 0.0, 0.0, 0.0
yaw_ref, yaw_ref_dot, yaw_ref_ddot = 0.0, 0.0, 0.0
angular_velocity = np.zeros((3, 1))
angular_acceleration = np.zeros((3, 1))
translational_position_in_I = np.zeros((3, 1))
translational_velocity_in_I = np.zeros((3, 1))
translational_position_in_I_user = np.zeros((3, 1))
translational_velocity_in_I_user = np.zeros((3, 1))
translational_acceleration_in_I_user = np.zeros((3, 1))
	
#ode_instance = ode_inputs([roll, pitch, yaw], yaw_ref, yaw_ref_dot, yaw_ref_ddot, angular_velocity, angular_acceleration, translational_position_in_I,
#              translational_velocity_in_I, translational_position_in_I_user, translational_velocity_in_I_user, translational_acceleration_in_I_user)

ode_instance=ode_inputs([roll, pitch, yaw], yaw_ref, yaw_ref_dot, yaw_ref_ddot, angular_velocity, angular_acceleration, translational_position_in_I, translational_velocity_in_I, translational_position_in_I_user, translational_velocity_in_I_user, translational_acceleration_in_I_user)

pid_instance=PID_controller(gains_instance,ode_instance,flight_params_instance)

def WrapperMain_function(target_folder, controller_type, wrapper_control_parameters, wrapper_foldername, wrapper_filename, max_simulation_time, csv_file_path_abnormalities, Wrapper_execution, visualization_flag):
    print("Wrapper loop starts here")
    global mu_x, mu_y, mu_z, u1, roll_ref, pitch_ref, roll_ref_dot, pitch_ref_dot, roll_ref_ddot, pitch_ref_ddot
    global angular_position_ref_dot, angular_position_ref_ddot, Jacobian_matrix_inverse, angular_position_dot
    global angular_error_dot, u2, u3, u4, mu_baseline_tran, mu_adaptive_tran, Moment_baseline, Moment_adaptive
    global mu_PD_baseline_tran, Moment_baseline_PI, e_tran, integral_eQe_tran, e_rot, integral_eQe_rot
    global epsilon_tran, integral_epsQeps_tran, epsilon_rot, integral_epsQeps_rot, e_transient_tran
    global integral_etQet_tran, e_transient_rot, integral_etQet_rot, omega_ref_dot, omega_cmd, omega_cmd_dot
    global Jacobian_matrix, Jacobian_matrix_dot, angular_error

    #%% File settings
    
    # Parse command-line parameters
    
    m_filename = "drone_bb.py"
    m_timestep = 0.005 #0.005 - 0.01
    m_length = 1.0
    m_visualization = "irrlicht"
    # m_datapath = "C:/workspace/chrono/data/"  # change this accordingly to where you saved chrono data
    m_datapath = "C:/ProgramData/Anaconda/envs/chrono/Library/data/"  # change this accordingly to where you saved chrono data
    
    # m_filename_env = os.getcwd() + "/environments/environment3.py"
    m_filename_env = os.getcwd() + "/environments/environmentA.py"

    #%% Importing bodies and constraints from the solidworks generated file
    
    # ----------------------------------------------------------------
    #                     INCLUDE ENVIRONMENT
    # ----------------------------------------------------------------
    
    # environment_included = True
    
    environment_included = False
    
    # ----------------------------------------------------------------
    #                     %%%%%%%%%%%%%%%%%%%%%%
    # ----------------------------------------------------------------
    
    #  load the file generated by the SolidWorks CAD plugin
    #  and add it to the ChSystem.
    
    # Remove the trailing .py and add / in case of file without ./
    m_absfilename = os.path.abspath(m_filename)
    m_modulename = os.path.splitext(m_absfilename)[0]
    
    exported_items = chrono.ImportSolidWorksSystem(m_modulename)
    
    # Print exported items
    for my_item in exported_items:
    	print (my_item.GetName())
    
    # Add items to the physical system
    my_system = chrono.ChSystemNSC()
    for my_item in exported_items:
    	my_system.Add(my_item)
    
    if environment_included == True:
    
        # Remove the trailing .py and add / in case of file without ./
        m_absfilename_env = os.path.abspath(m_filename_env)
        m_modulename_env = os.path.splitext(m_absfilename_env)[0]
        
        exported_items_env = chrono.ImportSolidWorksSystem(m_modulename_env)
        
        # Print exported items
        for my_item_env in exported_items_env:
        	print (my_item_env.GetName())
         # Add items to the physical system
        	my_system.Add(my_item_env)
        
        # Assigning names to the bodies imported from solidworks and checking if they are found
        my_environment = my_system.SearchBody('environment1-1')
        my_environment = my_system.SearchBody('environmentA-1')
        if my_environment :
            print('Environment found!')
        if not my_environment :
            sys.exit('Error: cannot find Environment from its name in the C::E system!')
            
   #%% Defining Wrapper control parameters and creating folders and files            
    if Wrapper_execution == True:		
        folder_path = os.path.join(target_folder, wrapper_foldername)
    
        # Create the folder if it doesn't exist
        if not os.path.exists(folder_path):
            os.mkdir(folder_path)
            print(f"Folder '{wrapper_foldername}' created successfully.")
        
        wrapper_filename_csv = wrapper_filename  + ".log"
        log_file_path = os.path.join(folder_path, wrapper_filename_log)
        
        
        #Wrapper parameters passed-------------------------------------
    my_ball_density = wrapper_control_parameters["my_ball_density"]

    #%% Solver parameters
    
    #my_system.SetMaxPenetrationRecoverySpeed(1.00)
    # my_solver = chrono.ChSolverBB() # default solver set by the solidworks pychrono module
    my_solver = chrono.ChSolverPSOR() # same solver as 'demo_MBS_collisionNSC'
    my_system.SetSolver(my_solver)
    my_solver.SetMaxIterations(1000) #600 #1000
    my_solver.EnableWarmStart(True)
    
    chrono.ChCollisionModel.SetDefaultSuggestedEnvelope(0.001) #0.003 #0.001
    chrono.ChCollisionModel.SetDefaultSuggestedMargin(0.0005) #0.003 #0.0005
    chrono.ChCollisionSystemBullet.SetContactBreakingThreshold(0.001) #0.002 #0.001

# %%

    #%% System and General parameters
    my_system.Set_G_acc(chrono.ChVectorD(0,-flight_params_instance.G_acc,0))
    # my_system.Set_G_acc(chrono.ChVectorD(0,0,0)) # No Gravity
    position_local_pixhawk = chrono.ChVectorD(0.0293, 0.04925, 0) # position of the "pixhawk's center" wrt local frame
    position_pixhawk_fromCOG = chrono.ChVectorD(-0.0214807964657055, 0.0779592340719906, -0.0000487571767365452) # position of the "pixhawk's center" wrt the COG of the drone frame
    global_coord = chrono.ChCoordsysD(chrono.ChVectorD(0,0,0), chrono.ChQuaternionD(1,0,0,0)) # Global reference frame
    pixhawk_csys = chrono.ChCoordsysD(position_local_pixhawk,chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0)) # Coordinate System Pixhawk
    
    pixhawk_csys_fixed = chrono.ChCoordsysD(position_local_pixhawk,chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0))# Coordinate System as Pixhawk convention but fixed to ground
    
    force_1_5_pos = chrono.ChVectorD(-0.08760601358, -0.0085, -0.10859150436) # position wrt local frame of where to apply the thrust force generated by the motors'couple identified by number 1 & 5
    force_2_6_pos = chrono.ChVectorD(0.08812691616, -0.0085, -0.10834502049) # position wrt local frame of where to apply the thrust force generated by the motors'couple identified by number 2 & 6
    force_3_7_pos = chrono.ChVectorD(0.08760601358, -0.0085, 0.10859150436) # position wrt local frame of where to apply the thrust force generated by the motors'couple identified by number 3 & 7
    force_4_8_pos = chrono.ChVectorD(-0.08812691616, -0.0085, 0.10834502049) # position wrt local frame of where to apply the thrust force generated by the motors'couple identified by number 4 & 8
    
    

    #%% Assigning names to the bodies imported from solidworks and checking if they are found
    
    my_ground = my_system.SearchBody('ground')
    if my_ground :
        print('Ground found!')
    if not my_ground :
        sys.exit('Error: cannot find ground from its name in the C::E system!')
    
    my_frame = my_system.SearchBody('drone_big_box-1')
    if my_frame :
        print('Frame found!')
    if not my_frame :
        sys.exit('Error: cannot find drone frame  from its name in the C::E system!')
     
    my_box = my_system.SearchBody('box_big_200x200x100-1')
    if my_box :
        print('Box found!')
    if not my_box :
        sys.exit('Error: cannot find box from its name in the C::E system!')
        
    my_prop1 = my_system.SearchBody('3_blade_prop-1')
    if my_prop1 :
        print('Propeller_1 found!')
    if not my_prop1 :
        sys.exit('Error: cannot find Propeller_1 from its name in the C::E system!')
        
    my_prop2 = my_system.SearchBody('3_blade_prop-2')
    if my_prop2 :
        print('Propeller_2 found!')
    if not my_prop2 :
        sys.exit('Error: cannot find Propeller_2 from its name in the C::E system!')
        
    my_prop3 = my_system.SearchBody('3_blade_prop-3')
    if my_prop3 :
        print('Propeller_3 found!')
    if not my_prop3 :
        sys.exit('Error: cannot find Propeller_3 from its name in the C::E system!')
        
    my_prop4 = my_system.SearchBody('3_blade_prop-4')
    if my_prop4 :
        print('Propeller_4 found!')
    if not my_prop4 :
        sys.exit('Error: cannot find Propeller_4 from its name in the C::E system!')
        
    my_prop5 = my_system.SearchBody('3_blade_prop-5')
    if my_prop5 :
        print('Propeller_5 found!')
    if not my_prop5 :
        sys.exit('Error: cannot find Propeller_5 from its name in the C::E system!')
        
    my_prop6 = my_system.SearchBody('3_blade_prop-6')
    if my_prop6 :
        print('Propeller_6 found!')
    if not my_prop6 :
        sys.exit('Error: cannot find Propeller_6 from its name in the C::E system!')
        
    my_prop7 = my_system.SearchBody('3_blade_prop-7')
    if my_prop7 :
        print('Propeller_7 found!')
    if not my_prop7 :
        sys.exit('Error: cannot find Propeller_7 from its name in the C::E system!')
        
    my_prop8 = my_system.SearchBody('3_blade_prop-8')
    if my_prop8 :
        print('Propeller_8 found!')
    if not my_prop8 :
        sys.exit('Error: cannot find Propeller_8 from its name in the C::E system!')
        
    # Assigning names to the Coordinate Systems/Markers imported from solidworks and checking if they are found
    my_marker1 = my_system.SearchMarker('Coordinate System1')
    if my_marker1 :
        print('Marker_1 found!')
    if not my_marker1 :
        sys.exit('Error: cannot find marker1 from its name in the C::E system!')
        
    my_marker2 = my_system.SearchMarker('Coordinate System2')
    if my_marker2 :
        print('Marker_2 found!')
    if not my_marker2 :
        sys.exit('Error: cannot find marker2 from its name in the C::E system!')
        
    my_marker3 = my_system.SearchMarker('Coordinate System3')
    if my_marker3 :
        print('Marker_3 found!')
    if not my_marker3 :
        sys.exit('Error: cannot find marker3 from its name in the C::E system!')
        
    my_marker4 = my_system.SearchMarker('Coordinate System4')
    if my_marker4 :
        print('Marker_4 found!')
    if not my_marker4 :
        sys.exit('Error: cannot find marker4 from its name in the C::E system!')
        
    my_marker5 = my_system.SearchMarker('Coordinate System5')
    if my_marker5 :
        print('Marker_5 found!')
    if not my_marker5 :
        sys.exit('Error: cannot find marker5 from its name in the C::E system!')
        
    my_marker6 = my_system.SearchMarker('Coordinate System6')
    if my_marker6 :
        print('Marker_6 found!')
    if not my_marker6 :
        sys.exit('Error: cannot find marker6 from its name in the C::E system!')
        
    my_marker7 = my_system.SearchMarker('Coordinate System7')
    if my_marker7 :
        print('Marker_7 found!')
    if not my_marker7 :
        sys.exit('Error: cannot find marker7 from its name in the C::E system!')
        
    my_marker8 = my_system.SearchMarker('Coordinate System8')
    if my_marker8 :
        print('Marker_8 found!')
    if not my_marker8 :
        sys.exit('Error: cannot find marker8 from its name in the C::E system!')   
        
    
    
    #%% Create bodies and floor
    
    # Create contact materials and set their properties
    contact_material_floor = chrono.ChMaterialSurfaceNSC()
    contact_material_floor.SetFriction(1) # 1
    contact_material_floor.SetDampingF(0.5) # 0.5
    contact_material_ball = chrono.ChMaterialSurfaceNSC()
    # contact_material_ball.SetFriction(2) # 0.01
    # contact_material_ball.SetRollingFriction(1) # 0.03
    # contact_material_ball.SetSpinningFriction(1) # 0.03
    # contact_material_ball.SetDampingF(0.1) # 1
    
     
    # Create a floor
    mfloor = chrono.ChBodyEasyBox(50, 0.1, 50, 1000,True,True, contact_material_floor)
    mfloor.SetName('Floor')
    mfloor.SetBodyFixed(True)
    mfloor_Yposition = 0.3
    mfloor.SetPos(chrono.ChVectorD(0,-mfloor_Yposition,0))
    # mfloor.SetPos(chrono.ChVectorD(0,-0.5,0))
    mfloor.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/light_gray.png"))
    # mfloor.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/concrete.jpg"))
    # mfloor.GetVisualShape(0).SetColor(chrono.ChColor(1, 1, 1))
    my_system.Add(mfloor)
    
    my_ball1 = chrono.ChBodyEasySphere(0.0254,      # radius size # 0.0254 - 0.01905 - 0.015875
                                          my_ball_density,     # density 7850
                                          True,     # visualization?
                                          True,     # collision?
                                          contact_material_ball)  # contact material
    my_ball1.SetName('Ball_1')
    my_ball1.SetPos(chrono.ChVectorD(-0.05,-0.15,0.065)) # -0.05,-0.15,0
    # my_ball1.SetPos(chrono.ChVectorD(-0.05,-0.15,0))
    my_ball1.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/redwhite.png"))
    # my_ball1.GetVisualShape(0).SetColor(chrono.ChColor(0, 1, 0))
    my_system.Add(my_ball1)
    
    # my_ball1.SetPos_dt(chrono.ChVectorD(0,0,10))
    
    my_ball2 = chrono.ChBodyEasySphere(0.0254,      # radius size
                                          my_ball_density,     # density 7850
                                          True,     # visualization?
                                          True,     # collision?
                                          contact_material_ball)  # contact material
    my_ball2.SetName('Ball_2')
    my_ball2.SetPos(chrono.ChVectorD(0.05,-0.15,0.065))
    # my_ball2.SetPos(chrono.ChVectorD(0.05,-0.15,0))
    my_ball2.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/checker2.png"))
    # my_ball2.GetVisualShape(0).SetColor(chrono.ChColor(0, 0, 1))
    my_system.Add(my_ball2)
    
    # my_ball2.SetWvel_loc(chrono.ChVectorD(0,0,5))
    # my_ball2.SetPos_dt(chrono.ChVectorD(0,1,0))
# %%
    
        #%% Create additional reference systems (ChMarkers) 
    
    # Create a local reference system with origin in pixhawk and with NED (North East Down) convention
    marker_pixhawk =chrono.ChMarker()
    marker_pixhawk.SetName('Coordinate System Pixhawk')
    my_frame.AddMarker(marker_pixhawk)
    marker_pixhawk.Impose_Abs_Coord(pixhawk_csys)
    
    # Create a local reference system with origin in pixhawk and with Global Frame convention (Y up)
    
    pixhawk_csys_2 = chrono.ChCoordsysD(position_local_pixhawk,chrono.ChQuaternionD(1,0,0,0)) # Coordinate System Pixhawk
    
    marker_pixhawk_2 =chrono.ChMarker()
    marker_pixhawk_2.SetName('Coordinate System Pixhawk Global Frame convention')
    my_frame.AddMarker(marker_pixhawk_2)
    marker_pixhawk_2.Impose_Abs_Coord(pixhawk_csys_2)
    
    
    # my_frame.SetWvel_loc(chrono.ChVectorD(1,0,0)) # ROLL YAW PITCH
    # my_frame.SetWvel_par(chrono.ChVectorD(1,0,0)) # ROLL YAW PITCH
    
    # my_ball3.SetWvel_par(chrono.ChVectorD(1,0,0)) # ROLL YAW PITCH
    
    # # Rotation matrix that represents a rotation of minus pi/2 (-90 degrees) around the x-axis
    # RR = chrono.ChMatrix33D()
    # RRX_minusPI2 = [[1,0,0],
    #                 [0,0,-1],
    #                 [0,1,0]]
    # RR.SetMatr(RRX_minusPI2)
    
    # Rotation matrix that represents a rotation of plus pi/2 (90 degrees) around the x-axis
    RR = chrono.ChMatrix33D()
    RRX_plusPI2 = [[ 1, 0, 0],
                    [0, 0, 1],
                    [0,-1, 0]]
    RR.SetMatr(RRX_plusPI2)
    
    # QQ = chrono.ChQuaternionD(0.70710678118,-0.70710678118,0,0) # Rotation around x of -pi/2
    # QQ = chrono.ChQuaternionD(0.70710678118,0,-0.70710678118,0) # Rotation around y of -pi/2
    # QQ = chrono.ChQuaternionD(0.70710678118,0,0,-0.70710678118) # Rotation around z of -pi/2
    
    # QQ = chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0) # Rotation around x of pi/2
    # QQ = chrono.ChQuaternionD(0.70710678118,0,0.70710678118,0) # Rotation around y of pi/2
    # QQ = chrono.ChQuaternionD(0.70710678118,0,0,0.70710678118) # Rotation around z of pi/2
    
    # QQ = chrono.ChQuaternionD(0.96592582628,0.2588190451,0,0) # Rotation around x of 30 degrees
    
    # marker_pixhawk.SetRot(RR)
    # marker_pixhawk.SetRot(QQ)
    # my_frame.SetRot(RR)
    # my_frame.SetRot(QQ)
    
    # # Create a local reference system with origin in pixhawk and with NED (North East Down) convention
    # marker_ball3 =chrono.ChMarker()
    # marker_ball3.SetName('Coordinate System Ball 3')
    # my_ball3.AddMarker(marker_ball3)
    # marker_ball3.Impose_Abs_Coord(chrono.ChCoordsysD(chrono.ChVectorD(0,1,0),chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0)))
    
    # Identify Local reference system of Box
    my_box_csys = my_box.GetFrame_REF_to_abs().GetCoord()
    
    # Identify Local reference system of Ball_1
    my_ball1_csys = my_ball1.GetFrame_REF_to_abs().GetCoord()
    
    # Identify Local reference system of Ball_2
    my_ball2_csys = my_ball2.GetFrame_REF_to_abs().GetCoord()
    
    # Identify Local reference system of drone frame
    my_frame_csys = my_frame.GetFrame_REF_to_abs().GetCoord()
    
    #%% Making the Propellers spin   
    
    revolute_frame1 = my_marker1.GetAbsFrame()
    link_motor1 = chrono.ChLinkMotorRotationSpeed()
    link_motor1.Initialize(my_prop1, my_frame, revolute_frame1)
    link_motor1.SetSpindleConstraint(chrono.ChLinkMotorRotationSpeed.SpindleConstraint_CYLINDRICAL)
    # link_motor1.SetMotorFunction(chrono.ChFunction_Const(5.0*chrono.CH_C_2PI))  # 5.0 Hz to rad/s
    # link_motor1.SetMotorFunction(chrono.ChFunction_Const(250*chrono.CH_C_2PI))  # 250 Hz to rad/s
    my_system.Add(link_motor1)
    
    # omega_fun = chrono.ChFunction_Const(300)
    # link_motor1.SetMotorFunction(chrono.ChFunction_Const(omega_fun))
    
    revolute_frame2 = my_marker2.GetAbsFrame()
    link_motor2 = chrono.ChLinkMotorRotationSpeed()
    link_motor2.Initialize(my_prop2, my_frame, revolute_frame2)
    link_motor2.SetSpindleConstraint(chrono.ChLinkMotorRotationSpeed.SpindleConstraint_CYLINDRICAL)
    # link_motor2.SetMotorFunction(chrono.ChFunction_Const(5.0*chrono.CH_C_2PI))  # 5.0 Hz to rad/s
    my_system.Add(link_motor2)
    
    revolute_frame3 = my_marker3.GetAbsFrame()
    link_motor3 = chrono.ChLinkMotorRotationSpeed()
    link_motor3.Initialize(my_prop3, my_frame, revolute_frame3)
    link_motor3.SetSpindleConstraint(chrono.ChLinkMotorRotationSpeed.SpindleConstraint_CYLINDRICAL)
    # link_motor3.SetMotorFunction(chrono.ChFunction_Const(5.0*chrono.CH_C_2PI))  # 5.0 Hz to rad/s
    my_system.Add(link_motor3)
    
    revolute_frame4 = my_marker4.GetAbsFrame()
    link_motor4 = chrono.ChLinkMotorRotationSpeed()
    link_motor4.Initialize(my_prop4, my_frame, revolute_frame4)
    link_motor4.SetSpindleConstraint(chrono.ChLinkMotorRotationSpeed.SpindleConstraint_CYLINDRICAL)
    # link_motor4.SetMotorFunction(chrono.ChFunction_Const(5.0*chrono.CH_C_2PI))  # 5.0 Hz to rad/s
    my_system.Add(link_motor4)
    
    revolute_frame5 = my_marker5.GetAbsFrame()
    link_motor5 = chrono.ChLinkMotorRotationSpeed()
    link_motor5.Initialize(my_prop5, my_frame, revolute_frame5)
    link_motor5.SetSpindleConstraint(chrono.ChLinkMotorRotationSpeed.SpindleConstraint_CYLINDRICAL)
    # link_motor5.SetMotorFunction(chrono.ChFunction_Const(-5.0*chrono.CH_C_2PI))  # 5.0 Hz to rad/s
    my_system.Add(link_motor5)
    
    revolute_frame6 = my_marker6.GetAbsFrame()
    link_motor6 = chrono.ChLinkMotorRotationSpeed()
    link_motor6.Initialize(my_prop6, my_frame, revolute_frame6)
    link_motor6.SetSpindleConstraint(chrono.ChLinkMotorRotationSpeed.SpindleConstraint_CYLINDRICAL)
    # link_motor6.SetMotorFunction(chrono.ChFunction_Const(-5.0*chrono.CH_C_2PI))  # 5.0 Hz to rad/s
    my_system.Add(link_motor6)
    
    revolute_frame7 = my_marker7.GetAbsFrame()
    link_motor7 = chrono.ChLinkMotorRotationSpeed()
    link_motor7.Initialize(my_prop7, my_frame, revolute_frame7)
    link_motor7.SetSpindleConstraint(chrono.ChLinkMotorRotationSpeed.SpindleConstraint_CYLINDRICAL)
    # link_motor7.SetMotorFunction(chrono.ChFunction_Const(-5.0*chrono.CH_C_2PI))  # 5.0 Hz to rad/s
    my_system.Add(link_motor7)
    
    revolute_frame8 = my_marker8.GetAbsFrame()
    link_motor8 = chrono.ChLinkMotorRotationSpeed()
    link_motor8.Initialize(my_prop8, my_frame, revolute_frame8)
    link_motor8.SetSpindleConstraint(chrono.ChLinkMotorRotationSpeed.SpindleConstraint_CYLINDRICAL)
    # link_motor8.SetMotorFunction(chrono.ChFunction_Const(-5.0*chrono.CH_C_2PI))  # 5.0 Hz to rad/s
    my_system.Add(link_motor8)
    
    
    #%% Computing Center Of Mass (COM) of the system: drone frame + box + propellers + balls
    
    # Get the mass of each body
    my_frame_mass = my_frame.GetMass()
    my_box_mass = my_box.GetMass()
    my_prop_mass = my_prop1.GetMass() # same for each propeller
    my_ball1_mass = my_ball1.GetMass()
    my_ball2_mass = my_ball2.GetMass()
    
    mass_total = my_frame_mass + my_box_mass + 8*(my_prop_mass)
    mass_total_wballs = my_frame_mass + my_box_mass + 8*(my_prop_mass) + my_ball1_mass + my_ball2_mass
    
    COG_total = chrono.ChVectorD()
    COG = chrono.ChVectorD()
    
    # !! The rest of the computation must be executed inside the final while loop !!

    #%% Forces and Torques
    
    my_frame.Accumulate_force(chrono.ChVectorD(0,0,0),chrono.VNULL,True)
    
    # Mixer Matrix for the realization of the thrust generated by each motor (T1, T2, T3, T4) given the control inputs (u1, u2, u3, u4)
    l_x = 0.0881269 # distance between centerline of the drone and the motors along x direction in Local NED convention
    l_y = 0.1083450 # distance between centerline of the drone and the motors along y direction in Local NED convention
    c_t = 0.01 # WRONG/RANDOM VALUE drag coefficient of propellers 0.01
    
    # U_mat = np.array([[ 1,    1,    1,    1  ],  # For QUADcopter config, not X8
    #                   [ l_y,  l_y, -l_y, -l_y],
    #                   [-l_x,  l_x,  l_x, -l_x],
    #                   [-c_t,  c_t, -c_t,  c_t]])
    
    # Mixer matrix for X8 configuration copter
    # [   1,   1,    1,    1,    1,    1,    1,    1]
    # [ l_y, l_y, -l_y, -l_y,  l_y,  l_y, -l_y, -l_y]
    # [-l_x, l_x,  l_x, -l_x, -l_x,  l_x,  l_x, -l_x]
    # [-c_t, c_t, -c_t,  c_t,  c_t, -c_t,  c_t, -c_t]
    
    # Moore-Penrose pseudo-inverse of mixer matrix
    # [1/8,  1/(8*l_y), -1/(8*l_x), -1/(8*c_t)],
    # [1/8,  1/(8*l_y),  1/(8*l_x),  1/(8*c_t)],
    # [1/8, -1/(8*l_y),  1/(8*l_x), -1/(8*c_t)],
    # [1/8, -1/(8*l_y), -1/(8*l_x),  1/(8*c_t)],
    # [1/8,  1/(8*l_y), -1/(8*l_x),  1/(8*c_t)],
    # [1/8,  1/(8*l_y),  1/(8*l_x), -1/(8*c_t)],
    # [1/8, -1/(8*l_y),  1/(8*l_x),  1/(8*c_t)],
    # [1/8, -1/(8*l_y), -1/(8*l_x), -1/(8*c_t)]
     
    # U_mat_inv = LA.inv(U_mat)
    
    U_mat_inv = np.array([[1/8,  1/(8*l_y), -1/(8*l_x), -1/(8*c_t)],
                          [1/8,  1/(8*l_y),  1/(8*l_x),  1/(8*c_t)],
                          [1/8, -1/(8*l_y),  1/(8*l_x), -1/(8*c_t)],
                          [1/8, -1/(8*l_y), -1/(8*l_x),  1/(8*c_t)],
                          [1/8,  1/(8*l_y), -1/(8*l_x),  1/(8*c_t)],
                          [1/8,  1/(8*l_y),  1/(8*l_x), -1/(8*c_t)],
                          [1/8, -1/(8*l_y),  1/(8*l_x),  1/(8*c_t)],
                          [1/8, -1/(8*l_y), -1/(8*l_x), -1/(8*c_t)]])
    
    #%% Trajectory parameters
    
    # ----------------------------------------------------------------
    #!!!                     CHOOSE THE TRAJECTORY
    # ----------------------------------------------------------------
    
    # trajectory_type = 'circular_trajectory'
    
    # trajectory_type = 'hover_trajectory'
    
    # trajectory_type = 'square_trajectory'
    
    #trajectory_type = 'roundedRectangle_trajectory'
    
    trajectory_type = 'piecewisePolynomial_trajectory'
    
    # ----------------------------------------------------------------
    #                     %%%%%%%%%%%%%%%%%%%%%%
    # ----------------------------------------------------------------
    
    
    if trajectory_type == 'circular_trajectory':
        # Circular trajectory at constant altitude
        radius_trajectory = 3 # 5
        angular_velocity_trajectory = 0.2 # 0.2
        altitude_trajectory = -1 # -1
        
        #################################################################################################################################################################
        # Create a ChLinePath geometry, and insert sub-paths # CIRCLE TRAJECTORY
        mpath = chrono.ChLinePath()
        marc1 = chrono.ChLineArc(chrono.ChCoordsysD(chrono.ChVectorD(-radius_trajectory, abs(altitude_trajectory) + 0.3, 0), chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0)), radius_trajectory, chrono.CH_C_2PI, 0, False) # CIRCLE TRAJECTORY
        # marc1 = chrono.ChLineArc(chrono.ChCoordsysD(chrono.ChVectorD(-2.5, 1.3, 0), chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0)), 5, chrono.CH_C_2PI, 0, False) # CIRCLE TRAJECTORY
        mpath.AddSubLine(marc1)
        mpath.Set_closed(True)
    
        # Create a ChLineShape, a visualization asset for lines.
        # The ChLinePath is a special type of ChLine and it can be visualized.
        mpathasset = chrono.ChLineShape()
        mpathasset.SetLineGeometry(mpath)
        mpathasset.SetColor(chrono.ChColor(0,0,0))
        mfloor.AddVisualShape(mpathasset)
        ####################################################################################################################################################################
        
    elif trajectory_type == 'hover_trajectory':
        # Hover trajectory at constant altitude
        altitude_trajectory = -1 # -1
    
    elif trajectory_type == 'square_trajectory':
        # Square trajectory at constant altitude
        square_side_size = 5 # 5
        linear_velocity_trajectory = 3.5 # 1
        altitude_trajectory = -1
        ##################################################################################################################################################################
        # Create a ChLinePath geometry, and insert sub-paths # SQUARE TRAJECTORY
        mpath = chrono.ChLinePath()
    
        seg1 = chrono.ChLineSegment(chrono.ChVectorD(0,abs(altitude_trajectory) + 0.3,0),chrono.ChVectorD(square_side_size,abs(altitude_trajectory) + 0.3,0))
        seg2 = chrono.ChLineSegment(chrono.ChVectorD(square_side_size,abs(altitude_trajectory) + 0.3,0),chrono.ChVectorD(square_side_size,abs(altitude_trajectory) + 0.3,square_side_size))
        seg3 = chrono.ChLineSegment(chrono.ChVectorD(square_side_size,abs(altitude_trajectory) + 0.3,square_side_size),chrono.ChVectorD(0,abs(altitude_trajectory) + 0.3,square_side_size))
        seg4 = chrono.ChLineSegment(chrono.ChVectorD(0,abs(altitude_trajectory) + 0.3,square_side_size),chrono.ChVectorD(0,abs(altitude_trajectory) + 0.3,0))
    
        mpath.AddSubLine(seg1)
        mpath.AddSubLine(seg2)
        mpath.AddSubLine(seg3)
        mpath.AddSubLine(seg4)
        mpath.Set_closed(True)
    
        # Create a ChLineShape, a visualization asset for lines.
        # The ChLinePath is a special type of ChLine and it can be visualized.
        mpathasset = chrono.ChLineShape()
        mpathasset.SetLineGeometry(mpath)
        mpathasset.SetColor(chrono.ChColor(0,0,0))
        mfloor.AddVisualShape(mpathasset)
        ####################################################################################################################################################################
    
    elif trajectory_type == 'roundedRectangle_trajectory':
        # Rounded rectangle trajectory at a constant altitude
        # 22.5 seconds "Stadium": 5, 0, 2, 1, -1
        length_horizontal = 4
        length_vertical = 0
        rounding_radius = 1
        linear_velocity_trajectory = 1.5 # 1.2
        altitude_trajectory = -1.1
        
        # length_horizontal = 4
        # length_vertical = 0
        # rounding_radius = 0.3
        # linear_velocity_trajectory = 1.2 
        # altitude_trajectory = -1.1
        
        # length_horizontal = 5
        # length_vertical = 0
        # rounding_radius = 2
        # linear_velocity_trajectory = 1 
        # altitude_trajectory = -1
        ##################################################################################################################################################################
        # Create a ChLinePath geometry, and insert sub-paths # ROUNDED RECTANGLE TRAJECTORY
        mpath = chrono.ChLinePath()
    
        seg1 = chrono.ChLineSegment(chrono.ChVectorD(0,abs(altitude_trajectory) + 0.3,0),chrono.ChVectorD(length_horizontal,abs(altitude_trajectory) + 0.3,0))
        arc2 = chrono.ChLineArc(chrono.ChCoordsysD(chrono.ChVectorD(length_horizontal, abs(altitude_trajectory) + 0.3, rounding_radius), chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0)), rounding_radius, -PI/2, 0, True)
        seg3 = chrono.ChLineSegment(chrono.ChVectorD(length_horizontal + rounding_radius,abs(altitude_trajectory) + 0.3,rounding_radius),chrono.ChVectorD(length_horizontal + rounding_radius,abs(altitude_trajectory) + 0.3,rounding_radius + length_vertical))
        arc4 = chrono.ChLineArc(chrono.ChCoordsysD(chrono.ChVectorD(length_horizontal, abs(altitude_trajectory) + 0.3, rounding_radius + length_vertical), chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0)), rounding_radius, 0, PI/2, True)
        seg5 = chrono.ChLineSegment(chrono.ChVectorD(length_horizontal,abs(altitude_trajectory) + 0.3,2*rounding_radius + length_vertical),chrono.ChVectorD(0,abs(altitude_trajectory) + 0.3,2*rounding_radius + length_vertical))
        arc6 = chrono.ChLineArc(chrono.ChCoordsysD(chrono.ChVectorD(0, abs(altitude_trajectory) + 0.3, rounding_radius + length_vertical), chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0)), rounding_radius, PI/2, PI, True)
        seg7 = chrono.ChLineSegment(chrono.ChVectorD(-rounding_radius,abs(altitude_trajectory) + 0.3,rounding_radius + length_vertical),chrono.ChVectorD(-rounding_radius,abs(altitude_trajectory) + 0.3,rounding_radius))
        arc8 = chrono.ChLineArc(chrono.ChCoordsysD(chrono.ChVectorD(0, abs(altitude_trajectory) + 0.3, rounding_radius), chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0)), rounding_radius, -PI, -PI/2, True)
        
        mpath.AddSubLine(seg1)
        mpath.AddSubLine(arc2)
        mpath.AddSubLine(seg3)
        mpath.AddSubLine(arc4)
        mpath.AddSubLine(seg5)
        mpath.AddSubLine(arc6)
        mpath.AddSubLine(seg7)
        mpath.AddSubLine(arc8)
        mpath.Set_closed(True)
    
        # Create a ChLineShape, a visualization asset for lines.
        # The ChLinePath is a special type of ChLine and it can be visualized.
        mpathasset = chrono.ChLineShape()
        mpathasset.SetLineGeometry(mpath)
        mpathasset.SetColor(chrono.ChColor(0,0,0))
        mfloor.AddVisualShape(mpathasset)
        ####################################################################################################################################################################
        
    elif trajectory_type == 'piecewisePolynomial_trajectory':
        pp_coefficients = np.loadtxt(open(
                                  "trajectory_PolynomialCoefficientMatrix.csv",
                                  "rb"), delimiter=",", skiprows=0)
        waypointTimes = np.loadtxt(open("trajectory_WaypointTimes.csv", "rb"),
                                   delimiter=",", skiprows=0)
        
        trajectory_instance = piecewisePolynomial_trajectory()
        trajectory_instance.set_parameters(pp_coefficients, waypointTimes)
        
        # Create a ChLinePath geometry, and insert sub-paths
        mpath = chrono.ChLinePath()
        [pos_x, pos_y, pos_z] = trajectory_instance.ComputePositionVector(0.01)
        
        for i in range(pos_x.size - 1):
          mpath.AddSubLine(chrono.ChLineSegment(
            chrono.ChVectorD(pos_x[i],
                             -pos_z[i] + mfloor_Yposition,
                             pos_y[i]),
            chrono.ChVectorD(pos_x[i+1],
                             -pos_z[i+1] + mfloor_Yposition,
                             pos_y[i+1])))
        
        # Create a ChLineShape, a visualization asset for lines.
        # The ChLinePath is a special type of ChLine and it can be visualized.
        mpathasset = chrono.ChLineShape()
        mpathasset.SetLineGeometry(mpath)
        mpathasset.SetColor(chrono.ChColor(0,0,0))
        mfloor.AddVisualShape(mpathasset)

    #%% Controller Inizialization
    
    T = np.array([0,0,0,0,0,0,0,0]) # Thrust inizialization
    U = np.array([0,0,0,0])
    torque_total = 0
    roll_ref = 0
    pitch_ref = 0
    mu_x = 0
    mu_y = 0
    mu_z = 0
    mu_PD_baseline_tran = np.zeros((3,1))
    mu_baseline_tran = np.zeros((3,1))
    mu_adaptive_tran = np.zeros((3,1))
    Moment_baseline_PI = np.zeros((3,1))
    Moment_baseline = np.zeros((3,1))
    Moment_adaptive = np.zeros((3,1))
    
    omega_ref_dot = np.zeros((3,1))
    omega_ref = np.zeros((3,1))
    omega_cmd = np.zeros((3,1))
    omega_cmd_dot = np.zeros((3,1))
    Jacobian_matrix = np.matrix(np.zeros((3,3)))
    Jacobian_matrix_dot = np.matrix(np.zeros((3,3)))
    angular_error = np.zeros((3,1))
    angular_error_dot = np.zeros((3,1))
    integral_angular_error = np.zeros((3,1))
    
    e_omega_ref_cmd = np.zeros((3,1))
    integral_e_omega_ref_cmd = np.zeros((3,1))
    
    
    # Maximum thrust produced by a single motor = 1355 grams = 1.355 kg = 1.355 kg * 9.81 m/s^2 = 13.28 N
    # Maximum thrust produced by a motors'couple without loss of efficiency due to propeller interaction = 13.28 * 2 = 26.56 N
    # Maximum thrust produced by a motors'couple considering loss of efficiency due to propeller interaction = 26.56 N * 0.8 = 21.25 N
    # For reference see: https://www.getfpv.com/t-motor-pacer-v3-p2306-powerful-freestyle-motor-1750kv-1950kv-2550kv.html
    # T_MAX = 21.25 # [N] Maximum thrust that can be produced by a motors'couple
    T_MAX = 21.25/2 # [N] Maximum thrust that can be produced by a SINGLE motor = 10.625 N
    # T_MAX = 100000 # [N] Maximum thrust that can be produced by a SINGLE motor
    
    # Minimum thrust produced by a single motor = 80 grams = 0.08 kg = 0.08 kg * 9.81 m/s^2 = 0.7848 N
    # Minimum thrust produced by a motors'couple without loss of efficiency due to propeller interaction = 0.7848 * 2 = 1.5696 N
    # Minimum thrust produced by a motors'couple considering loss of efficiency due to propeller interaction = 1.5696 N * 0.8 = 1.255 N
    # T_MIN = 1.255 # [N] Minimum thrust that can be produced by a motors'couple
    T_MIN = 1.255/2 # [N] Minimum thrust that can be produced by a SINGLE motor = 0.6275 N
    # T_MIN = 0 # [N] Minimum thrust that can be produced by a SINGLE motor
    
    motor_efficiency_matrix = np.matrix(np.diag([1, 1, 1, 1, 1, 1, 1, 1]))
    
    # =============================================================================
    
    K_omega = 0.0000014166615 # Coefficent relating the propellers'thrust to the square of the angular velocity. T = K * omega^2
    K_torque = 5e-08 # [5e-08 - 5e-10] TO BE ESTIMATED!!! Coefficent relating the propellers'torque to the square of the angular velocity. Torque = K_torque * omega^2
    
    #########################
    # Roll filters gains (from matlab)
    A_phi_ref = np.matrix([[-15, -225],[1, 0]])
    B_phi_ref = np.array([[1],[0]])
    C_phi_ref = np.matrix([225, 0])
    D_phi_ref = 0
    # Pitch filters gains (from matlab)
    A_theta_ref = np.matrix([[-15, -225],[1, 0]])
    B_theta_ref = np.array([[1],[0]])
    C_theta_ref = np.matrix([225, 0])
    D_theta_ref = 0
    #########################

    #%% Controller gains and TYPE
    
    ##########################!!!
    controller_start_time = 0.1 # Time after the start of simulation at which the controller is switched ON
    
    #########################
    
    # ----------------------------------------------------------------
    #                     CHOOSE THE CONTROLLER
    # ----------------------------------------------------------------
    
    # controller_type = 'PID' # Check mass_total_estimated
    
    # controller_type = 'MRACwithBASELINE'
    
    # controller_type = 'TwoLayerMRACwithBASELINE'
    
    # controller_type = 'RobustMRACwithBASELINE'
    
    #controller_type = 'RobustTwoLayerMRACwithBASELINE'
    
    # controller_type = 'HybridMRACwithBASELINE'
    
    # controller_type = 'HybridTwoLayerMRACwithBASELINE'
    
    # controller_type = 'HybridRobustMRACwithBASELINE'
    
    # controller_type = 'HybridRobustTwoLayerMRACwithBASELINE'
    
    # controller_type = 'FunnelMRACwithBASELINE'
    
    # controller_type = 'FunnelTwoLayerMRACwithBASELINE'
    
    # controller_type = 'MRACwithBASELINE_SafetyMechanism'
    
    # ----------------------------------------------------------------
    #                     %%%%%%%%%%%%%%%%%%%%%%
    # ----------------------------------------------------------------
    #%% Control Algorithms ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    number_of_states=10
    # Initial conditions
    y0 = np.zeros((number_of_states,1))
    
    Y = np.zeros((number_of_states,1))
    Y_list = Y
    Y[:, 0] = np.ravel(y0)
    yin = y0
    
    dy = np.zeros((number_of_states,1))
    y = np.zeros((number_of_states,1))
    print("Size of y before passing")
    print(y.shape)

    
    my_frame_pos_GLOB = my_frame.GetPos()

    #%% Irrlicht visualization
    if visualization_flag == True:    
        #******************************************************************************    
        # Create the Irrlicht visualization
        vis = irr.ChVisualSystemIrrlicht()
        vis.AttachSystem(my_system)
        # vis.SetWindowSize(1024,768)
        vis.SetWindowSize(1536,1152)
        vis.SetWindowTitle('X8-Copter - Controller: ' + controller_type)
        vis.Initialize()
        vis.AddLogo(chrono.GetChronoDataPath() + 'logo_pychrono_alpha.png')
        vis.AddSkyBox()
        # vis.AddCamera(chrono.ChVectorD(2.5, 1.5, 0.5)) #(1,1,1) - (2.5,1.5,0.5) FIXED CAMERA
        vis.AddCamera(chrono.ChVectorD(my_frame_pos_GLOB.x, 0, my_frame_pos_GLOB.z) + chrono.ChVectorD(-1.5, 2, 1.5), my_frame_pos_GLOB)
        # vis.AddCamera(chrono.ChVectorD(6,1.5,3), chrono.ChVectorD(3,0,-2))
        # vis.AddCamera(chrono.ChVectorD(2, 1, 3), chrono.ChVectorD(2,0.5,1.5))
        vis.AddTypicalLights()
        # vis.AddLightWithShadow(chrono.ChVectorD(3,6,2),    # point
        #                               chrono.ChVectorD(0,0,0),    # aimpoint
        #                               12,                 # radius (power)
        #                               1,11,              # near, far
        #                               55)                # angle of FOV
        vis.AddLightWithShadow(chrono.ChVectorD(0,5,0),    # point
                                      chrono.ChVectorD(3,2,0),    # aimpoint
                                      5,                 # radius (power)
                                      1,8,              # near, far
                                      55)                # angle of FOV
        vis.BindAll()
    #******************************************************************************    

    #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # Inizialization of arrays/lists to store data
    
    my_frame_pos_GLOB = my_frame.GetPos() # Do this if you want to print the position value of the drone frame to monitor
    my_frame_quat = my_frame.GetRot()
    my_ball1_pos = my_ball1.GetPos()
    my_ball2_pos = my_ball2.GetPos()
    
    
    
    
    times=[] # Array to store times
    
    # List to store xyz position of the drone frame - Do this if you want to append the information to a list
    my_frame_pos_GLOB_list = [['Time [s]','Drone Frame X position [m]', 'Drone Frame Y position [m]', 'Drone Frame Z position [m]']] 
    
    # GLOBAL COORDINATES of PIXHAWK, List to store xyz position and quaternion(e0,e1,e2,e3) of the pixhawk,
    # its velocity and angular velocity, its acceleration and angular acceleration
    state_pixhawk_GLOB = [['Time [s]','Pixhawk X position [m]', 'Pixhawk Y position [m]', 'Pixhawk Z position [m]',
                          'Pixhawk e0 quaternion term [-]', 'Pixhawk e1 quaternion term [-]', 'Pixhawk e2 quaternion term [-]', 'Pixhawk e3 quaternion term [-]',
                          'Pixhawk X velocity [m/s]', 'Pixhawk Y velocity [m/s]', 'Pixhawk Z velocity [m/s]',
                          'Pixhawk angular velocity wrt X axis [rad/s]', 'Pixhawk angular velocity wrt Y axis [rad/s]', 'Pixhawk angular velocity wrt Z axis [rad/s]',
                          'Pixhawk X acceleration [m/s^2]', 'Pixhawk Y acceleration [m/s^2]', 'Pixhawk Z acceleration [m/s^2]',
                          'Pixhawk angular acceleration wrt X axis [rad/s^2]', 'Pixhawk angular acceleration wrt Y axis [rad/s^2]', 'Pixhawk angular acceleration wrt Z axis [rad/s^2]']]
    
    # LOCAL COORDINATES of PIXHAWK, List to store of the pixhawk,
    # its velocity and angular velocity, its acceleration and angular acceleration
    state_pixhawk_LOC = [['Time [s]', 'Pixhawk X velocity [m/s]', 'Pixhawk Y velocity [m/s]', 'Pixhawk Z velocity [m/s]',
                          'Pixhawk angular velocity wrt X axis [rad/s]', 'Pixhawk angular velocity wrt Y axis [rad/s]', 'Pixhawk angular velocity wrt Z axis [rad/s]',
                          'Pixhawk X acceleration [m/s^2]', 'Pixhawk Y acceleration [m/s^2]', 'Pixhawk Z acceleration [m/s^2]',
                          'Pixhawk angular acceleration wrt X axis [rad/s^2]', 'Pixhawk angular acceleration wrt Y axis [rad/s^2]', 'Pixhawk angular acceleration wrt Z axis [rad/s^2]']]
    
    # GLOBAL and LOCAL rotational acceleration of the drone frame
    my_frame_Wacc_list = [['Time [s]','Drone Frame GLOBAL angular acceleration wrt X axis [rad/s^2]', 'Drone Frame GLOBAL angular acceleration wrt Y axis [rad/s^2]', 'Drone Frame GLOBAL angular acceleration wrt Z axis [rad/s^2]',
                           'Drone Frame LOCAL angular acceleration wrt X axis [rad/s^2]', 'Drone Frame LOCAL angular acceleration wrt Y axis [rad/s^2]', 'Drone Frame LOCAL angular acceleration wrt Z axis [rad/s^2]']]
    
    # List to store xyz position of Ball_1, Ball_2, COG_total_box in LOCAL COORDINATES seen from the BOX REFERENCE SYSTEM
    my_ball_pos_LOC_list = [['Time [s]','Ball_1 X position [m]', 'Ball_1 Y position [m]', 'Ball_1 Z position [m]',
                             'Ball_2 X position [m]', 'Ball_2 Y position [m]', 'Ball_2 Z position [m]',
                             'COG X position [m]', 'COG Y position [m]', 'COG Z position [m]']]
    
    # Rotation 321 sequence of euler angle (roll, pitch, yaw) of pixhawk
    # ACTUALLY IT LOOKS LIKE (ROLL, YAW, PITCH)
    pixhawk_euler_list = [['Time [s]','Pixhawk roll [rad]', 'Pixhawk pitch [rad]', 'Pixhawk yaw [rad]']]
    
    COG_total_list = [['Time [s]','COG X position [m]', 'COG Y position [m]', 'COG Z position [m]']]
    
    COG_list = [['Time [s]','COG X position [m]', 'COG Y position [m]', 'COG Z position [m]']]
    
    # List to store xyz components of the contact force of Ball_1 and Ball_2 in GLOBAL COORDINATES 
    my_ball_cfr_list = [['Time [s]','Ball1 X contact force [N]', 'Ball1 Y contact force [N]', 'Ball1 Z contact force [N]',
                         'Ball2 X contact force [N]', 'Ball2 Y contact force [N]', 'Ball2 Z contact force [N]']]
    
    # List to store angular velocities of the motors
    omega_8_list = [['Time [s]', 'Motor 1 ang. vel. [rad/s]', 'Motor 2 ang. vel. [rad/s]', 'Motor 3 ang. vel. [rad/s]', 'Motor 4 ang. vel. [rad/s]',
                     'Motor 5 ang. vel. [rad/s]', 'Motor 6 ang. vel. [rad/s]', 'Motor 7 ang. vel. [rad/s]', 'Motor 8 ang. vel. [rad/s]']]
    
    pos_pixhawk_LOC_to_GLOB_list = [['Time [s]','Pixhawk X position [m]', 'Pixhawk Y position [m]', 'Pixhawk Z position [m]']]
    
    pos_pixhawk_LOC_to_GLOB_NED_list = [['Time [s]','Pixhawk X position [m]', 'Pixhawk Y position [m]', 'Pixhawk Z position [m]']]
    
    torque_list = [['Time [s]', 'Torque Motor 1 [Nm]', 'Torque Motor 2 [Nm]', 'Torque Motor 3 [Nm]', 'Torque Motor 4 [Nm]',
                    'Torque Motor 5 [Nm]', 'Torque Motor 6 [Nm]', 'Torque Motor 7 [Nm]', 'Torque Motor 8 [Nm]']]
    
    T_list = [['Time [s]', 'Thrust Motor 1 [N]', 'Thrust Motor 2 [N]', 'Thrust Motor 3 [N]', 'Thrust Motor 4 [N]',
                    'Thrust Motor 5 [N]', 'Thrust Motor 6 [N]', 'Thrust Motor 7 [N]', 'Thrust Motor 8 [N]']]
    
    size_DATA = 47
    DATA = np.zeros((size_DATA,1))
    
    # # Collision report
    # my_rep = MyReportContactCallback()
    # controller_z_output = 0
    #--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    
    date = datetime.datetime.now()
    
    start_simulation_time = time.time() # Time acquired in order to measure the execution time of the simulation
    

    # Simulation loop
    while my_system.GetChTime()<max_simulation_time:
    #****************************************************************************** 
   # while vis.Run():
        if visualization_flag == True:
            vis.BeginScene()
            # vis.AddCamera(my_frame_pos_GLOB + chrono.ChVectorD(0.5, -0.3, -0.4), my_frame_pos_GLOB) # MOVING CAMERA (1.5, 1, 1)
            # vis.AddCamera(my_frame_pos_GLOB + chrono.ChVectorD(0.2, 0.3, -0.6), my_frame_pos_GLOB) # MOVING CAMERA (1.5, 1, 1)
            # vis.AddCamera(my_frame_pos_GLOB + chrono.ChVectorD(-0.6, 0.9, -1.8), my_frame_pos_GLOB) # MOVING CAMERA (1.5, 1, 1)
            # vis.AddCamera(my_frame_pos_GLOB + chrono.ChVectorD(1.2, 0.9, -0.9), my_frame_pos_GLOB) # MOVING CAMERA (1.5, 1, 1)
            # vis.AddCamera(my_frame_pos_GLOB + chrono.ChVectorD(1.2, 0.9, 0.9), my_frame_pos_GLOB) # MOVING CAMERA (1.5, 1, 1)
            # vis.AddCamera(my_frame_pos_GLOB + chrono.ChVectorD(-0.8, 0.1, 0), my_frame_pos_GLOB) # MOVING CAMERA (-0.5, 0.2, 0)
            
            # vis.AddCamera(my_frame_pos_GLOB + chrono.ChVectorD(2, 0.2, 1), my_frame_pos_GLOB) # MOVING CAMERA (-0.5, 0.2, 0)
            
            # vis.AddCamera(chrono.ChVectorD(my_frame_pos_GLOB.x, 0, my_frame_pos_GLOB.z) + chrono.ChVectorD(2, 2, -1), my_frame_pos_GLOB) # MOVING CAMERA (-0.5, 0.2, 0)
            # vis.AddCamera(chrono.ChVectorD(my_frame_pos_GLOB.x, 0, my_frame_pos_GLOB.z) + chrono.ChVectorD(-1.5, 2, 1.5), my_frame_pos_GLOB) # MOVING CAMERA (-0.5, 0.2, 0)
            
            # if my_system.GetChTime() < 6:
            #     vis.AddCamera(chrono.ChVectorD(my_frame_pos_GLOB.x, 0, my_frame_pos_GLOB.z) + chrono.ChVectorD(-1.5, 2, 1.5), my_frame_pos_GLOB)
            
            # if my_system.GetChTime() >= 6 and my_system.GetChTime() < 7:
            #     vis.AddCamera(chrono.ChVectorD(my_frame_pos_GLOB.x, 0, my_frame_pos_GLOB.z) + chrono.ChVectorD(1.5, 2, -1.5), my_frame_pos_GLOB)
            
            # vis.AddCamera(chrono.ChVectorD(my_frame_pos_GLOB.x, 0, my_frame_pos_GLOB.z) + chrono.ChVectorD(-1.5, 2, 1.5), my_frame_pos_GLOB)
            
            # Camera fixed with drone orientation
            # if my_system.GetChTime() > 0.1:
            #     # vis.AddCamera(pixhawk_rotmat*(pos_pixhawk_LOC + chrono.ChVectorD(-0.55, 0, -0.1)), my_frame_pos_GLOB + chrono.ChVectorD(0, 0.05, 0)) # MOVING CAMERA
            #     vis.AddCamera(pixhawk_rotmat*(pos_pixhawk_LOC + chrono.ChVectorD(-0.4, 0, -0.1)), my_frame_pos_GLOB + chrono.ChVectorD(0, 0.05, 0)) # MOVING CAMERA 
                
            
            vis.Render()
            irr.drawCoordsys(vis, marker_pixhawk.GetAbsCoord(), 0.5) # Draw the coordinate system of pixhawk (NED) during the simulation
            # irr.drawCoordsys(vis, marker_pixhawk_2.GetAbsCoord(), 0.5) # Draw the coordinate system of pixhawk (Y up) during the simulation
            # irr.drawCoordsys(vis, pixhawk_csys_fixed, 4) # Draw the fixed coordinate system of pixhawk during the simulation
            # irr.drawCoordsys(vis, marker_ball3.GetAbsCoord(), 0.5) # Draw the coordinate system of ball3 during the simulation
            irr.drawCoordsys(vis, global_coord, 1) # Draw the Global coordinate system during the simulation
            # irr.drawCoordsys(vis, my_ball1_csys, 0.3) #Draw the csys of ball1
            # irr.drawCoordsys(vis, my_prop1.GetCoord(), 0.3) #Draw the csys of propeller 1
            # irr.drawCoordsys(vis, my_ball2_csys, 0.3) #Draw the csys of ball2
            # irr.drawAllCOGs(vis,0.05) # Draw the Center Of Gravity of all bodies
            vis.EndScene()
        #******************************************************************************    
        
            if not vis.Run():
                break
        my_system.DoStepDynamics(m_timestep)
        
        my_frame.Empty_forces_accumulators() # Command that MUST be used in conjunction with Accumulate_force() and Accumulate_torque() used below
        
        # # Collision report -------------------------------------------------------------------------------------
        # my_rep.ResetList()
        # my_system.GetContactContainer().ReportAllContacts(my_rep)
        # crt_list = my_rep.GetList()
        # print('time=', my_system.GetChTime(), ' num. contacts=', my_system.GetContactContainer().GetNcontacts())
        # print(*crt_list, sep='\n')
        # # ------------------------------------------------------------------------------------------------------
        
        ##################################################################################################################################################################################
             
        ################ Build lists to export data ################
        time_now = my_system.GetChTime() # Time "inside" the simulation
        times.append(time_now)
        
        simulation_time = time.time() - start_simulation_time # Time that the simulation is taking
        
        # Global coordinates of the origin of the drone frame containing just the position
        my_frame_pos_GLOB = my_frame.GetPos() 
        my_frame_pos_GLOB_list.append([time_now, chvector_to_list(my_frame_pos_GLOB)[0], chvector_to_list(my_frame_pos_GLOB)[1], chvector_to_list(my_frame_pos_GLOB)[2]])
    
    
    
        # GLOBAL COORDINATES of PIXHAWK---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        coord_pixhawk_GLOB = marker_pixhawk.GetAbsCoord() # Global coordinates of the pixhawk containing both its position and rotation (quaternion)
        coord_dt_pixhawk_GLOB = marker_pixhawk.GetAbsCoord_dt() # Global velocities of the pixhawk derived from its position and rotation (quaternion)
        coord_dtdt_pixhawk_GLOB = marker_pixhawk.GetAbsCoord_dtdt() # Global accelerations of the pixhawk derived from its position and rotation (quaternion)
        Wvel_pixhawk_GLOB = marker_pixhawk.GetAbsWvel() # Angular velocity of the pixhawk respect to global coordinates, expressed in global coordinates
        Wacc_pixhawk_GLOB = marker_pixhawk.GetAbsWacc() # Angular acceleration of the pixhawk respect to global coordinates, expressed in global coordinates
        state_pixhawk_GLOB.append([time_now, chcoordsys_to_list(coord_pixhawk_GLOB)[0][0], chcoordsys_to_list(coord_pixhawk_GLOB)[0][1], chcoordsys_to_list(coord_pixhawk_GLOB)[0][2],
                                  chcoordsys_to_list(coord_pixhawk_GLOB)[1][0], chcoordsys_to_list(coord_pixhawk_GLOB)[1][1], chcoordsys_to_list(coord_pixhawk_GLOB)[1][2], chcoordsys_to_list(coord_pixhawk_GLOB)[1][3],
                                  chcoordsys_to_list(coord_dt_pixhawk_GLOB)[0][0], chcoordsys_to_list(coord_dt_pixhawk_GLOB)[0][1], chcoordsys_to_list(coord_dt_pixhawk_GLOB)[0][2],
                                  chvector_to_list(Wvel_pixhawk_GLOB)[0], chvector_to_list(Wvel_pixhawk_GLOB)[1], chvector_to_list(Wvel_pixhawk_GLOB)[2],
                                  chcoordsys_to_list(coord_dtdt_pixhawk_GLOB)[0][0], chcoordsys_to_list(coord_dtdt_pixhawk_GLOB)[0][1], chcoordsys_to_list(coord_dtdt_pixhawk_GLOB)[0][2],
                                  chvector_to_list(Wacc_pixhawk_GLOB)[0], chvector_to_list(Wacc_pixhawk_GLOB)[1], chvector_to_list(Wacc_pixhawk_GLOB)[2]])
        
        #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        
        
        # LOCAL COORDINATES of PIXHAWK---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        pixhawk_rotmat = chrono.ChMatrix33D(coord_pixhawk_GLOB.rot) # rotation matrix of the pixhawk given by pychrono (computed using pixhawk quaternion expressed in glob coord)
        pixhawk_rotmat_array = np.asarray(pixhawk_rotmat.GetMatr())
        
        pixhawk_rotmat_F = rotmat_fromQ_Glob_to_Loc_asChMatrix33(coord_pixhawk_GLOB.rot) # rotation matrix of the pixhawk to go from Global to Local coordinates (computed using Mattia's function: rotmat_fromQ_Glob_to_Loc_asarray)
        pixhawk_rotmat_F_array = np.asarray(pixhawk_rotmat_F.GetMatr())
        
        # pixhawk_rotmat_T_array = np.transpose(np.asarray(pixhawk_rotmat.GetMatr())) # TRANSPOSED rotation matrix of the pixhawk given by pychrono (computed using pixhawk quaternion expressed in glob coord)
        # pixhawk_rotmat_T = chrono.ChMatrix33D()
        # pixhawk_rotmat_T.SetMatr(pixhawk_rotmat_T_array)
        
        pixhawk_csys_fixed_rotmat_array = rotmat_fromQ_Glob_to_Loc_asarray(pixhawk_csys_fixed.rot)
        pixhawk_csys_fixed_rotmat = rotmat_fromQ_Glob_to_Loc_asChMatrix33(pixhawk_csys_fixed.rot)
        pixhawk_csys_fixed_rotmat_array_transposed = np.transpose(pixhawk_csys_fixed_rotmat_array)
        
        rotmat_from_pixhawk_fixed_to_pixhawk = np.matmul(pixhawk_rotmat_F_array,pixhawk_csys_fixed_rotmat_array_transposed)
        
        
        pos_pixhawk_LOC = pixhawk_rotmat_F * coord_pixhawk_GLOB.pos # Local position of the pixhawk
        vel_pixhawk_LOC = pixhawk_rotmat_F * coord_dt_pixhawk_GLOB.pos # Local velocities of the pixhawk
        acc_pixhawk_LOC = pixhawk_rotmat_F * coord_dtdt_pixhawk_GLOB.pos # Local accelerations of the pixhawk 
        Wvel_pixhawk_LOC = pixhawk_rotmat_F * Wvel_pixhawk_GLOB # Local Angular velocity of the pixhawk 
        Wacc_pixhawk_LOC = pixhawk_rotmat_F * Wacc_pixhawk_GLOB # Local Angular acceleration of the pixhawk 
        state_pixhawk_LOC.append([time_now, chvector_to_list(vel_pixhawk_LOC)[0], chvector_to_list(vel_pixhawk_LOC)[1], chvector_to_list(vel_pixhawk_LOC)[2],
                                  chvector_to_list(Wvel_pixhawk_LOC)[0], chvector_to_list(Wvel_pixhawk_LOC)[1], chvector_to_list(Wvel_pixhawk_LOC)[2],
                                  chvector_to_list(acc_pixhawk_LOC)[0], chvector_to_list(acc_pixhawk_LOC)[1], chvector_to_list(acc_pixhawk_LOC)[2],
                                  chvector_to_list(Wacc_pixhawk_LOC)[0], chvector_to_list(Wacc_pixhawk_LOC)[1], chvector_to_list(Wacc_pixhawk_LOC)[2]])
        
        pos_pixhawk_LOC_to_GLOB = pixhawk_rotmat * pos_pixhawk_LOC # Global position of pixhawk obtained starting from the Local position and premultiplying times the rotation matrix
        pos_pixhawk_LOC_to_GLOB_NED = RR * pos_pixhawk_LOC_to_GLOB # Global position of pixhawk in NED convention obtained starting from the Local position and premultiplying times the rotation matrix
        pos_pixhawk_LOC_to_GLOB_list.append([time_now, chvector_to_list(pos_pixhawk_LOC_to_GLOB)[0], chvector_to_list(pos_pixhawk_LOC_to_GLOB)[1], chvector_to_list(pos_pixhawk_LOC_to_GLOB)[2]])
        pos_pixhawk_LOC_to_GLOB_NED_list.append([time_now, chvector_to_list(pos_pixhawk_LOC_to_GLOB_NED)[0], chvector_to_list(pos_pixhawk_LOC_to_GLOB_NED)[1], chvector_to_list(pos_pixhawk_LOC_to_GLOB_NED)[2]])
        vel_pixhawk_LOC_to_GLOB = pixhawk_rotmat * vel_pixhawk_LOC # Global velocity of pixhawk obtained starting from the Local velocity and premultiplying times the rotation matrix
        vel_pixhawk_LOC_to_GLOB_NED = RR * vel_pixhawk_LOC_to_GLOB # Global velocity of pixhawk in NED convention obtained starting from the Local position and premultiplying times the rotation matrix
        Wvel_pixhawk_LOC_to_GLOB = pixhawk_rotmat * Wvel_pixhawk_LOC # Global angular velocity of pixhawk obtained starting from the Local position and premultiplying times the rotation matrix
        Wvel_pixhawk_LOC_to_GLOB_NED = RR * Wvel_pixhawk_LOC_to_GLOB # Global angular velocity of pixhawk in NED convention obtained starting from the Local position and premultiplying times the rotation matrix
        #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        # Computing Center Of Mass (COM) of the system: drone frame + box + propellers + balls
        
        # Compute the position (in global coordinates) of the bodies
        # my_box_ref = my_box.GetFrame_REF_to_abs().GetCoord().pos # this gives the position of the auxillary csys imported from/defined in SolidWorks
        my_box_pos = my_box.GetFrame_COG_to_abs().GetCoord().pos # = same as asking for .GetPos() --> meaning GetPos() refers to the COG position!!!!
        my_prop1_pos = my_prop1.GetPos()
        my_prop2_pos = my_prop2.GetPos()
        my_prop3_pos = my_prop3.GetPos()
        my_prop4_pos = my_prop4.GetPos()
        my_prop5_pos = my_prop5.GetPos()
        my_prop6_pos = my_prop6.GetPos()
        my_prop7_pos = my_prop7.GetPos()
        my_prop8_pos = my_prop8.GetPos()
        
        # Compute the COG in Global Coordinates
        # (First you must put the ChVector (position) and then you can multiply it by a float (mass). Order is important!!!)
        COG_total = (my_frame_pos_GLOB * my_frame_mass + my_box_pos * my_box_mass + 
                    (my_prop1_pos + my_prop2_pos + my_prop3_pos + my_prop4_pos + my_prop5_pos + my_prop6_pos + my_prop7_pos + my_prop8_pos)*8*(my_prop_mass) + 
                    my_ball1_pos * my_ball1_mass + my_ball2_pos * my_ball2_mass)*(1/mass_total_wballs)
        
        COG_total_list.append([time_now, chvector_to_list(COG_total)[0], chvector_to_list(COG_total)[1], chvector_to_list(COG_total)[2]])
        
        COG = (my_frame_pos_GLOB * my_frame_mass + my_box_pos * my_box_mass + 
              (my_prop1_pos + my_prop2_pos + my_prop3_pos + my_prop4_pos + my_prop5_pos + my_prop6_pos + my_prop7_pos + my_prop8_pos)*8*(my_prop_mass)) *(1/mass_total)
        
        COG_list.append([time_now, chvector_to_list(COG)[0], chvector_to_list(COG)[1], chvector_to_list(COG)[2]])
        
        my_COG_local = my_frame_csys.TransformParentToLocal(COG) # Position of COG seen from the local reference system of the frame
        
        #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        # Ball position seen from Box refrence system
        my_ball1_pos_box = my_box_csys.TransformParentToLocal(my_ball1_pos) # Position of Ball1 seen from the local reference system of the Box
        my_ball2_pos_box = my_box_csys.TransformParentToLocal(my_ball2_pos) # Position of Ball1 seen from the local reference system of the Box
        COG_total_box = my_box_csys.TransformParentToLocal(COG_total) # Position of COG_total seen from the local reference system of the Box
        my_ball_pos_LOC_list.append([time_now, chvector_to_list(my_ball1_pos_box)[0], chvector_to_list(my_ball1_pos_box)[1], chvector_to_list(my_ball1_pos_box)[2],
                                     chvector_to_list(my_ball2_pos_box)[0], chvector_to_list(my_ball2_pos_box)[1], chvector_to_list(my_ball2_pos_box)[2],
                                     chvector_to_list(COG_total_box)[0], chvector_to_list(COG_total_box)[1], chvector_to_list(COG_total_box)[2]])
        
        
        
        # # Local velocity of ball3
        # my_ball3_rotmat = my_ball3.GetA() # rotation matrix of ball3
        # coord_dt_ball3_LOC = my_ball3_rotmat * my_ball3.GetCoord_dt().pos # Local velocity of ball3
        
        # # Rotation 321 sequence of euler angle (roll, pitch, yaw) of pixhawk
        # pixhawk_euler_list.append([time_now, chvector_to_list(euler321_fromQ_asChVector(coord_pixhawk_GLOB.rot))[0], chvector_to_list(euler321_fromQ_asChVector(coord_pixhawk_GLOB.rot))[1], chvector_to_list(euler321_fromQ_asChVector(coord_pixhawk_GLOB.rot))[2]])
        # # pixhawk_euler = euler321_fromQ_asChVector(coord_pixhawk_GLOB.rot)
        # pixhawk_euler = euler321_fromQ_asChVector(coord_pixhawk_GLOB.rot) # ROLL YAW PITCH, at rest set at (90,0,0) degrees
        # pixhawk_euler_deg_trunc = ['%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[0]), '%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[1]), '%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[2])]
        
        # # Rotation 321 sequence of euler angle (roll, pitch, yaw) of pixhawk ALA METHOD
        # # quat_pixhawk = marker_pixhawk_2.GetAbsCoord().rot
        # quat_pixhawk = marker_pixhawk.GetAbsCoord().rot
        # quat_pixhawk_e0 = quat_pixhawk.e0
        # quat_pixhawk_e1 = -quat_pixhawk.e1
        # quat_pixhawk_e2 = quat_pixhawk.e2
        # quat_pixhawk_e3 = -quat_pixhawk.e3
        # quat_pixhawk_new = chrono.ChQuaternionD(quat_pixhawk_e0, quat_pixhawk_e1, quat_pixhawk_e3, quat_pixhawk_e2) #pixhawk quaternion with y and z components flipped
        
        # ==========================================================================================================================================================================
        # Rotation 321 sequence of euler angle (roll, pitch, yaw) of pixhawk ALA METHOD - CORRECT - 
        quat_pixhawk = marker_pixhawk_2.GetAbsCoord().rot
        quat_pixhawk_e0 = quat_pixhawk.e0
        quat_pixhawk_e1 = -quat_pixhawk.e1
        quat_pixhawk_e2 = quat_pixhawk.e2
        quat_pixhawk_e3 = -quat_pixhawk.e3
        quat_pixhawk_new = chrono.ChQuaternionD(quat_pixhawk_e0, quat_pixhawk_e1, quat_pixhawk_e3, quat_pixhawk_e2) #pixhawk quaternion with y and z components flipped
        
        pixhawk_rotmat_2 = rotmat_fromQ_Glob_to_Loc_asChMatrix33(quat_pixhawk_new)
        pixhawk_euler = euler321_from_rotmat(pixhawk_rotmat_2)
        pixhawk_euler_deg_trunc = ['%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[0]), '%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[1]), '%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[2])]
        
        # ==========================================================================================================================================================================
        
        # # pixhawk_rotmat_2 = rotmat_fromQ_Glob_to_Loc_asChMatrix33(marker_pixhawk_2.GetAbsCoord().rot)
        # pixhawk_rotmat_2 = rotmat_fromQ_Glob_to_Loc_asChMatrix33(quat_pixhawk_new)
        # # # pixhawk_rotmat_2 = rotmat_fromQ_Glob_to_Loc_asChMatrix33(quat_pixhawk)
        # pixhawk_euler = euler321_from_rotmat(pixhawk_rotmat_2)
        # # pixhawk_euler = euler321_fromQ_asChVector(quat_pixhawk_new) # ROLL YAW PITCH, at rest set at (90,0,0) degrees
        # pixhawk_euler_deg_trunc = ['%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[0]), '%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[1]), '%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[2])]
        
        
        # pixhawk_euler = euler321_from_rotmat_matlab(pixhawk_rotmat)
        # pixhawk_euler_deg_trunc = ['%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[0]), '%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[1]), '%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[2])]
        # pixhawk_euler_opposite = euler321_from_rotmat_matlab_opposite_direction(pixhawk_rotmat)
        # pixhawk_euler_opposite_deg_trunc = ['%.3f'%(chvector_to_list(rad2deg(pixhawk_euler_opposite))[0]), '%.3f'%(chvector_to_list(rad2deg(pixhawk_euler_opposite))[1]), '%.3f'%(chvector_to_list(rad2deg(pixhawk_euler_opposite))[2])]
        
        
        # ball3_rotmat = chrono.ChMatrix33D(marker_ball3.GetAbsCoord().rot)
        # ball3_euler = euler321_from_rotmat_matlab(ball3_rotmat)
        # ball3_euler_deg_trunc = ['%.3f'%(chvector_to_list(rad2deg(ball3_euler))[0]), '%.3f'%(chvector_to_list(rad2deg(ball3_euler))[1]), '%.3f'%(chvector_to_list(rad2deg(ball3_euler))[2])]
        
        
        # ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        if trajectory_type == 'circular_trajectory':
            # Circular trajectory at constant altitude
            [translational_position_in_I_user, translational_velocity_in_I_user, translational_acceleration_in_I_user] = circular_trajectory.user_defined_trajectory(time_now - controller_start_time, radius_trajectory, angular_velocity_trajectory, altitude_trajectory)
            [yaw_ref, yaw_ref_dot, yaw_ref_ddot] = circular_trajectory.user_defined_yaw(time_now - controller_start_time, angular_velocity_trajectory)
            
              
        elif trajectory_type == 'hover_trajectory':
            # Hover trajectory at constant altitude
            [translational_position_in_I_user, translational_velocity_in_I_user, translational_acceleration_in_I_user] = hover_trajectory.user_defined_trajectory(time_now - controller_start_time, altitude_trajectory)
            [yaw_ref, yaw_ref_dot, yaw_ref_ddot] = hover_trajectory.user_defined_yaw(time_now - controller_start_time)
    
        elif trajectory_type == 'square_trajectory':
            # Square trajectory at constant altitude
            [translational_position_in_I_user, translational_velocity_in_I_user, translational_acceleration_in_I_user] = square_trajectory.user_defined_trajectory(time_now - controller_start_time, square_side_size, linear_velocity_trajectory, altitude_trajectory)
            [yaw_ref, yaw_ref_dot, yaw_ref_ddot] = square_trajectory.user_defined_yaw(time_now - controller_start_time, square_side_size, linear_velocity_trajectory)
        
        elif trajectory_type == 'roundedRectangle_trajectory':
            # Rounded rectangle at constant altitude
            [translational_position_in_I_user, translational_velocity_in_I_user, translational_acceleration_in_I_user] = roundedRectangle_trajectory.user_defined_trajectory(time_now - controller_start_time, length_horizontal, length_vertical, rounding_radius, linear_velocity_trajectory, altitude_trajectory)
            [yaw_ref, yaw_ref_dot, yaw_ref_ddot] = roundedRectangle_trajectory.user_defined_yaw(time_now - controller_start_time, length_horizontal, length_vertical, rounding_radius, linear_velocity_trajectory, altitude_trajectory)
            
        elif trajectory_type == 'piecewisePolynomial_trajectory':
            [translational_position_in_I_user,
             translational_velocity_in_I_user,
             translational_acceleration_in_I_user] = (trajectory_instance.
                     user_defined_trajectory(time_now - controller_start_time))
            [yaw_ref,
             yaw_ref_dot,
             yaw_ref_ddot] = trajectory_instance.user_defined_yaw()
          
        roll = pixhawk_euler.x
        pitch = pixhawk_euler.y
        yaw = pixhawk_euler.z
        translational_position_in_I = np.array(chvector_to_list(pos_pixhawk_LOC_to_GLOB_NED)).reshape(3,1)
        translational_velocity_in_I = np.array(chvector_to_list(vel_pixhawk_LOC_to_GLOB_NED)).reshape(3,1)
        translational_position_error = translational_position_in_I - translational_position_in_I_user
        angular_error = np.array([roll - roll_ref, pitch - pitch_ref, (((yaw - yaw_ref + PI) % (2*PI)) - PI)]).reshape(3,1)
        angular_velocity = np.array(chvector_to_list(Wvel_pixhawk_LOC)).reshape(3,1)
        angular_acceleration = np.array(chvector_to_list(Wacc_pixhawk_LOC)).reshape(3,1)
        x_tran = np.append(translational_position_in_I, translational_velocity_in_I, axis=0)

        ode_instance.update([roll, pitch, yaw], yaw_ref, yaw_ref_dot, yaw_ref_ddot, angular_velocity, angular_acceleration, translational_position_in_I,
                      translational_velocity_in_I, translational_position_in_I_user, translational_velocity_in_I_user, translational_acceleration_in_I_user)
        
        ################## 
        # Applying AERODYNAMIC FORCE to the drone
        aerodynamic_velocity = np.array(chvector_to_list(vel_pixhawk_LOC)).reshape(3,1)
        aerodynamic_force = -0.5 * flight_params_instance.air_density_estimated * flight_params_instance.surface_area_estimated * flight_params_instance.drag_coefficient_matrix_estimated * aerodynamic_velocity * LA.norm(aerodynamic_velocity)
        my_frame.Accumulate_force(chrono.ChVectorD(aerodynamic_force[0].item(),aerodynamic_force[1].item(),aerodynamic_force[2].item()),chrono.ChVectorD(-0.006329836449057219, -0.05730872796244302, 3.945863912075595e-05),True)
        
        # Applying a constant WIND FORCE to the drone, expressed in pychrono global coordinate
        # my_frame.Accumulate_force(chrono.ChVectorD(1,0,0),chrono.ChVectorD(-0.006329836449057219, -0.05730872796244302, 3.945863912075595e-05),Fal
        
        ##################
        if Wrapper_execution == True:
            with open(log_file_path, mode='w', newline='') as log_file_wrapper:
                date = datetime.datetime.now(pytz.timezone('America/New_York'))
    
                # Write introductory information to the log file
                log_file.write(f"Execution Date: {date.month}-{date.day}-{date.year}\n")
                log_file.write(f"Simulation start time [s]: {date.hour}:{date.minute}:{date.second}\n")
                log_file.write(f"Controller type: {controller_type}\n")
                log_file.write(f"Trajectory: {trajectory_type}\n")
                log_file.write(f"Wrapper parameter: {my_ball_density}\n\n")
                if controller_type == "PID":
                    header_csv = ["Real Time[s]","Simulation time[s]", "translational_position_in_Ix[m]","translational_position_in_Iy[m]","translational_position_in_Iz[m]",
                                         "translational_velocity_in_Ix[m/s]","translational_velocity_in_Iy[m/s]","translational_velocity_in_Iz[m/s]", "roll[rad]","pitch[rad]","yaw[rad]",
                                         "angular_velocity_x[rad/s]","angular_velocity_y[rad/s]","angular_velocity_z[rad/s]", "roll_ref[rad]","pitch_ref[rad]", "yaw_ref[rad]",
                                         "roll_ref_dot[rad/s]", "pitch_ref_dot[rad/s]", "yaw_ref_dot[rad/s]","roll_ref_ddot[rad/s^2]", "pitch_ref_ddot[rad/s^2]", "yaw_ref_ddot[rad/s^2]",
                                         "translational_position_in_I_user_x[m]","translational_position_in_I_user_y[m]","translational_position_in_I_user_z[m]",
                                         "translational_velocity_in_I_user_x[m/s]","translational_velocity_in_I_user_y[m/s]","translational_velocity_in_I_user_z[m/s]",
                                         "translational_acceleration_in_I_user_x[m/s^2]","translational_acceleration_in_I_user_y[m/s^2]","translational_acceleration_in_I_user_z[m/s^2]",
                                        "mu_x[N]", "mu_y[N]","mu_z[N]","U1[N]", "U2[Nm]","U3[Nm]", "U4[Nm]","Thrust1[N]","Thrust2[N]","Thrust3[N]","Thrust4[N]","Thrust5[N]","Thrust6[N]","Thrust7[N]","Thrust8[N]"]
                
                else:   
                    # header_csv = ["Real Time[s]","Simulation time[s]", "translational_position_in_Ix[m]","translational_position_in_Iy[m]","translational_position_in_Iz[m]",
                    #                      "translational_velocity_in_Ix[m/s]","translational_velocity_in_Iy[m/s]","translational_velocity_in_Iz[m/s]", "roll[rad]","pitch[rad]","yaw[rad]",
                    #                      "angular_velocity_x[rad/s]","angular_velocity_y[rad/s]","angular_velocity_z[rad/s]",
                    #                      "x_ref_tran1[m]", "x_ref_tran2[m]", "x_ref_tran3[m]", "x_ref_tran4[m]", "x_ref_tran5[m]", "x_ref_tran6[m]",
                    #                      "roll_ref[rad]","pitch_ref[rad]", "yaw_ref[rad]",
                    #                      "roll_ref_dot[rad/s]", "pitch_ref_dot[rad/s]", "yaw_ref_dot[rad/s]","roll_ref_ddot[rad/s^2]", "pitch_ref_ddot[rad/s^2]", "yaw_ref_ddot[rad/s^2]",
                    #                      "omega_ref_x[rad/s]", "omega_ref_y[rad/s]", "omega_ref_z[rad/s]", "translational_position_in_I_user_x[m]","translational_position_in_I_user_y[m]","translational_position_in_I_user_z[m]",
                    #                      "translational_velocity_in_I_user_x[m/s]","translational_velocity_in_I_user_y[m/s]","translational_velocity_in_I_user_z[m/s]",
                    #                      "translational_acceleration_in_I_user_x[m/s^2]","translational_acceleration_in_I_user_y[m/s^2]","translational_acceleration_in_I_user_z[m/s^2]",
                    #                      "mu_x[N]", "mu_y[N]","mu_z[N]","U1[N]", "U2[Nm]","U3[Nm]", "U4[Nm]","Thrust1[N]","Thrust2[N]","Thrust3[N]","Thrust4[N]","Thrust5[N]","Thrust6[N]","Thrust7[N]","Thrust8[N]",
                    #                      "mu_baseline_tran_x[N]", "mu_baseline_tran_y[N]", "mu_baseline_tran_z[N]", 
                    #                      "mu_adaptive_tran_x[N]", "mu_adaptive_tran_y[N]", "mu_adaptive_tran_z[N]","mu_PD_baseline_tran_x[N]", "mu_PD_baseline_tran_y[N]", "mu_PD_baseline_tran_z[N]",
                    #                      "Moment_baseline_x[Nm]", "Moment_baseline_y[Nm]", "Moment_baseline_z[Nm]","Moment_adaptive_x[Nm]", "Moment_adaptive_y[Nm]", "Moment_adaptive_z[Nm]",
                    #                      "Moment_baseline_PI_x[Nm]", "Moment_baseline_PI_y[Nm]", "Moment_baseline_PI_z[Nm]"]
                    header_csv = ["Real Time[s]","Simulation time[s]", "translational_position_in_Ix[m]","translational_position_in_Iy[m]","translational_position_in_Iz[m]",
                                  "translational_velocity_in_Ix[m/s]","translational_velocity_in_Iy[m/s]","translational_velocity_in_Iz[m/s]", "roll[rad]","pitch[rad]","yaw[rad]",
                                  "angular_velocity_x[rad/s]","angular_velocity_y[rad/s]","angular_velocity_z[rad/s]",
                                  "x_ref_tran1[m]", "x_ref_tran2[m]", "x_ref_tran3[m]", "x_ref_tran4[m]", "x_ref_tran5[m]", "x_ref_tran6[m]",
                                  "roll_ref[rad]","pitch_ref[rad]", "yaw_ref[rad]",
                                  "roll_ref_dot[rad/s]", "pitch_ref_dot[rad/s]", "yaw_ref_dot[rad/s]","roll_ref_ddot[rad/s^2]", "pitch_ref_ddot[rad/s^2]", "yaw_ref_ddot[rad/s^2]",
                                  "omega_ref_x[rad/s]", "omega_ref_y[rad/s]", "omega_ref_z[rad/s]", "translational_position_in_I_user_x[m]","translational_position_in_I_user_y[m]","translational_position_in_I_user_z[m]",
                                  "translational_velocity_in_I_user_x[m/s]","translational_velocity_in_I_user_y[m/s]","translational_velocity_in_I_user_z[m/s]",
                                  "translational_acceleration_in_I_user_x[m/s^2]","translational_acceleration_in_I_user_y[m/s^2]","translational_acceleration_in_I_user_z[m/s^2]",
                                  "mu_x[N]", "mu_y[N]","mu_z[N]","U1[N]", "U2[Nm]","U3[Nm]", "U4[Nm]","Thrust1[N]","Thrust2[N]","Thrust3[N]","Thrust4[N]","Thrust5[N]","Thrust6[N]","Thrust7[N]","Thrust8[N]",
                                  "mu_baseline_tran_x[N]", "mu_baseline_tran_y[N]", "mu_baseline_tran_z[N]", 
                                  "mu_adaptive_tran_x[N]", "mu_adaptive_tran_y[N]", "mu_adaptive_tran_z[N]","mu_PD_baseline_tran_x[N]", "mu_PD_baseline_tran_y[N]", "mu_PD_baseline_tran_z[N]",
                                  "Moment_baseline_x[Nm]", "Moment_baseline_y[Nm]", "Moment_baseline_z[Nm]","Moment_adaptive_x[Nm]", "Moment_adaptive_y[Nm]", "Moment_adaptive_z[Nm]",
                                  "Moment_baseline_PI_x[Nm]", "Moment_baseline_PI_y[Nm]", "Moment_baseline_PI_z[Nm]",
                                  "omega_ref_dot_x[rad/s^2]", "omega_ref_dot_y[rad/s^2]", "omega_ref_dot_z[rad/s^2]",
                                  "omega_cmd_dot_x[rad/s^2]", "omega_cmd_dot_y[rad/s^2]", "omega_cmd_dot_z[rad/s^2]",
                                  "omega_cmd_x[rad/s]", "omega_cmd_y[rad/s]", "omega_cmd_z[rad/s]",
                                  "angular_position_dot_x[rad/s]", "angular_position_dot_y[rad/s]", "angular_position_dot_z[rad/s]"]
            
                
                log_file.write("Header:\n")
                log_file.write(", ".join(header_log) + "\n")
    
        else:
            # You can add other headers for other controller types here
            pass
            
        
        #$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
  
        if (time_now > controller_start_time): #0.1
                      
            # RUNGE KUTTA 4 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
            
            if controller_type == 'PID':
                # Integrating the ODEs through RK4 for PID controller
                
                yout = rk4.rk4singlestep(pid_instance.ode, m_timestep, time_now, yin,ode_instance)

                
                Y_list = np.append(Y_list,np.resize(yout,(number_of_states,1)), axis=1)
                yin = yout
                
                ############################### PID ###############################
                state_phi_ref_diff = yout[0:2]
                state_theta_ref_diff = yout[2:4]
                integral_position_tracking = yout[4:7]
                integral_angular_error = yout[7:10]
                ###################################################################
                
            
            # ----------------------------------------------------------------------------------------------------------------------------------------------------------------
            
        
            #U = np.array([u1, u2, u3, u4]) # array of control inputs (u1, u2, u3, u4)
            U = np.array([pid_instance.u1, pid_instance.u2, pid_instance.u3, pid_instance.u4])
    
            # T = np.matmul(U_mat_inv,U) # array of thrust of each motor (T1, T2, T3, T4, T5, T6, T7, T8)
            T = np.matmul(U_mat_inv,U).reshape(8,1) # array of thrust of each motor (T1, T2, T3, T4, T5, T6, T7, T8)
            
            # Thrust saturation
            for i in range(len(T)):
                if T[i][0] < T_MIN:
                    T[i][0] = T_MIN # if some component of the thrust force is smaller than the min thrust that can physically be generated set it to T_MIN
                if T[i][0] > T_MAX:
                    T[i][0] = T_MAX # if some component of the thrust force is greater than the max thrust that can physically be generated set it to T_MAX
    
            # Accounting for motor efficiency
            T = np.array(motor_efficiency_matrix * T)
    
            T_list.append([time_now, T[0][0], T[1][0], T[2][0], T[3][0], T[4][0], T[5][0], T[6][0], T[7][0]])         
            
            # Force applied with the command Accumulate_force()
            # my_frame.Accumulate_force(chrono.ChVectorD(0,T[0][0],0),force_1_5_pos,True)
            # my_frame.Accumulate_force(chrono.ChVectorD(0,T[1][0],0),force_2_6_pos,True)
            # my_frame.Accumulate_force(chrono.ChVectorD(0,T[2][0],0),force_3_7_pos,True)
            # my_frame.Accumulate_force(chrono.ChVectorD(0,T[3][0],0),force_4_8_pos,True)
            
            # my_frame.Accumulate_force(chrono.ChVectorD(0,T[4][0],0),force_1_5_pos,True)
            # my_frame.Accumulate_force(chrono.ChVectorD(0,T[5][0],0),force_2_6_pos,True)
            # my_frame.Accumulate_force(chrono.ChVectorD(0,T[6][0],0),force_3_7_pos,True)
            # my_frame.Accumulate_force(chrono.ChVectorD(0,T[7][0],0),force_4_8_pos,True)
            
            ### Motor thrust application position flipped wrt y and x axis (local NED convention)
            my_frame.Accumulate_force(chrono.ChVectorD(0,T[2][0],0),force_1_5_pos,True)
            my_frame.Accumulate_force(chrono.ChVectorD(0,T[3][0],0),force_2_6_pos,True)
            my_frame.Accumulate_force(chrono.ChVectorD(0,T[0][0],0),force_3_7_pos,True)
            my_frame.Accumulate_force(chrono.ChVectorD(0,T[1][0],0),force_4_8_pos,True)
            
            my_frame.Accumulate_force(chrono.ChVectorD(0,T[6][0],0),force_1_5_pos,True)
            my_frame.Accumulate_force(chrono.ChVectorD(0,T[7][0],0),force_2_6_pos,True)
            my_frame.Accumulate_force(chrono.ChVectorD(0,T[4][0],0),force_3_7_pos,True)
            my_frame.Accumulate_force(chrono.ChVectorD(0,T[5][0],0),force_4_8_pos,True)
            # ###
            
    
            # Computation of the angular velocities of the propellers
            # omega = np.sqrt((T/2)/K_omega) # I use half T because the thrust computed is not for a single motor but for a couple
            omega = np.sqrt(T/K_omega) # I use T because the thrust computed is for a single motor but not for a couple
            omega_8 = [omega[0], -omega[1], omega[2], -omega[3], -omega[4], omega[5], -omega[6], omega[7]]
            omega_8_list.append([time_now, omega_8[0], omega_8[1], omega_8[2], omega_8[3], omega_8[4], omega_8[5], omega_8[6], omega_8[7]])
        
            torque_1 = chrono.ChVectorD(0,(omega_8[0][0]**2 * K_torque),0) 
            torque_2 = chrono.ChVectorD(0,-(omega_8[1][0]**2 * K_torque),0)
            torque_3 = chrono.ChVectorD(0,(omega_8[2][0]**2 * K_torque),0)
            torque_4 = chrono.ChVectorD(0,-(omega_8[3][0]**2 * K_torque),0)
            torque_5 = chrono.ChVectorD(0,-(omega_8[4][0]**2 * K_torque),0)
            torque_6 = chrono.ChVectorD(0,(omega_8[5][0]**2 * K_torque),0)
            torque_7 = chrono.ChVectorD(0,-(omega_8[6][0]**2 * K_torque),0)
            torque_8 = chrono.ChVectorD(0,(omega_8[7][0]**2 * K_torque),0)  
            torque_list.append([time_now, chvector_to_list(torque_1)[1], chvector_to_list(torque_2)[1], chvector_to_list(torque_3)[1], chvector_to_list(torque_4)[1],
                                chvector_to_list(torque_5)[1], chvector_to_list(torque_6)[1], chvector_to_list(torque_7)[1], chvector_to_list(torque_8)[1]])
            torque_total = torque_1.y + torque_2.y + torque_3.y + torque_4.y + torque_5.y + torque_6.y + torque_7.y + torque_8.y
            
            # Torque applied with the command Accumulate_torque()
            my_frame.Accumulate_torque(torque_1, True)
            my_frame.Accumulate_torque(torque_2, True)
            my_frame.Accumulate_torque(torque_3, True)
            my_frame.Accumulate_torque(torque_4, True)
            my_frame.Accumulate_torque(torque_5, True)
            my_frame.Accumulate_torque(torque_6, True)
            my_frame.Accumulate_torque(torque_7, True)
            my_frame.Accumulate_torque(torque_8, True)
            
            # # Torque applied with the command Accumulate_torque() ALL SET TO ZERO
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
        
            ##############################################################################################################
            
            # DATA Export
            
            if controller_type == 'PID':
                
                ############################## PID ###############################
                DATA_vector = np.zeros((size_DATA,1))
                DATA_vector[0] = time_now
                DATA_vector[1] = simulation_time
                DATA_vector[2:5] = translational_position_in_I
                DATA_vector[5:8] = translational_velocity_in_I
                DATA_vector[8] = roll
                DATA_vector[9] = pitch
                DATA_vector[10] = yaw
                DATA_vector[11:14] = angular_velocity
                DATA_vector[14] = roll_ref
                DATA_vector[15] = pitch_ref
                DATA_vector[16] = yaw_ref
                #DATA_vector[17] = roll_ref_dot
                #DATA_vector[18] = pitch_ref_dot
                DATA_vector[19] = yaw_ref_dot
                #DATA_vector[20] = roll_ref_ddot
                #DATA_vector[21] = pitch_ref_ddot
                DATA_vector[22] = yaw_ref_ddot
                DATA_vector[23:26] = translational_position_in_I_user
                DATA_vector[26:29] = translational_velocity_in_I_user
                DATA_vector[29:32] = translational_acceleration_in_I_user
                DATA_vector[32] = mu_x
                DATA_vector[33] = mu_y
                DATA_vector[34] = mu_z
                DATA_vector[35] = pid_instance.u1
                DATA_vector[36] = pid_instance.u2
                DATA_vector[37] = pid_instance.u3
                DATA_vector[38] = pid_instance.u4
                DATA_vector[39:47] = T.reshape(8,1)
                
                DATA = np.append(DATA,np.resize(DATA_vector,(size_DATA,1)), axis=1)
                ###################################################################
                     
            
            # If the controller parameters go beyond 10^6, break the simulation
            if Wrapper_execution == True:
                if abs(u1)>(10**6) or abs(u2)>(10**6) or abs(u3)>(10**6) or abs(u4)>(10**6):
                    with open(csv_file_path_abnormalities, mode='a', newline='') as csv_file_wrapper_ab:
                        csv_writer = csv.writer(csv_file_wrapper_ab)
                        #csv_writer.writerow(["Time","Sum", "Average","Product","Maximum","Minimum"])
                        csv_writer.writerow([my_ball_density])  
                    break
            
            # Setting the propeller rotational velocities (all angular velocities are divided by 10)
            link_motor1.SetMotorFunction(chrono.ChFunction_Const(omega_8[0][0]/10))
            link_motor2.SetMotorFunction(chrono.ChFunction_Const(omega_8[1][0]/10))
            link_motor3.SetMotorFunction(chrono.ChFunction_Const(omega_8[2][0]/10))
            link_motor4.SetMotorFunction(chrono.ChFunction_Const(omega_8[3][0]/10))
            link_motor5.SetMotorFunction(chrono.ChFunction_Const(omega_8[4][0]/10))
            link_motor6.SetMotorFunction(chrono.ChFunction_Const(omega_8[5][0]/10))
            link_motor7.SetMotorFunction(chrono.ChFunction_Const(omega_8[6][0]/10))
            link_motor8.SetMotorFunction(chrono.ChFunction_Const(omega_8[7][0]/10))
            
            # link_motor1.SetSpeedFunction(chrono.ChFunction_Const(omega_8[0]))
            # omega_fun.Set_yconst(omega_8[0])
            # link_motor1.SetMotorFunction(chrono.ChFunction_Const(omega_fun))
        
        # # Payload Dropping
        # time_payloadDropping = 4 # 7AIAA, 11 
        # if (time_now > time_payloadDropping): # 5
        #     my_ball1.SetCollide(False)
        #     my_ball2.SetCollide(False)
            
        # if (time_now > (time_payloadDropping + 0.15)): # 5.15
        #     my_ball1.SetCollide(True)
        #     my_ball2.SetCollide(True)
            
        # Motor Failure#!!!
        # if (time_now > 2.5): # 4AIAA
        #     motor_efficiency_matrix = np.matrix(np.diag([1, 1, 0, 1, 1, 1, 0.3, 1]))
            
        # if (time_now > 1):
        #     maximumRollAngle = math.radians(25) # [rad] 25 - 32
        #     maximumPitchAngle = math.radians(25) # [rad] 25 - 32
    
    
    #========================================================================================================================================
    # # Dropping multiple balls one after the other
    #     collision_states = [True] * 10
    
    #     for i in range(0,10):
    #         variable_name = f'my_ball3_{i}'  # Get the variable name of the current ball
    #         if i>0:
    #             variable_name_previous = f'my_ball3_{i-1}'  # Get the variable name of the current ball
        
    #         if variable_name in globals():
    #             current_ball = globals()[variable_name]
    #         if i>0:
    #             if variable_name_previous in globals():
    #                 previous_ball = globals()[variable_name_previous]
        
    #         # Toggle collision state if the time condition is met
    #         if time_now > 5.0 + i * 0.05:
    #             collision_states[i] = False
    #             # if i>0:
    #             #     collision_states[i-1] = True
            
    #         # Set the collision state based on the flag
    #         current_ball.SetCollide(collision_states[i])
    #         if i>0:
    #             previous_ball.SetCollide(collision_states[i-1])
#========================================================================================================================================
    # --------------------------------------------------  
        
        
        # Print data to Console -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        #print ('\nSimulation time: ', time_now)
        print('Time the simulation is taking: ', '%.4f'%simulation_time)
        print_cosole_flag = False
        if (print_cosole_flag):
    
          # print('omega_ref_dot: ', '%.4f'%omega_ref_dot[0], '%.4f'%omega_ref_dot[1], '%.4f'%omega_ref_dot[2])
          # print('omega_ref: ', '%.4f'%omega_ref[0], '%.4f'%omega_ref[1], '%.4f'%omega_ref[2])
          # print('omega_cmd_dot: ', '%.8f'%omega_cmd_dot[0],
          #                          '%.8f'%omega_cmd_dot[1],
          #                          '%.8f'%omega_cmd_dot[2])
          # print('omega_cmd: ', '%.4f'%omega_cmd[0], '%.4f'%omega_cmd[1], '%.4f'%omega_cmd[2])
          # print('Jacobian_matrix_dot: ', Jacobian_matrix_dot)
          # print('Jacobian_matrix: ', Jacobian_matrix)
          # print('integral_angular_error: ', '%.4f'%integral_angular_error[0], '%.4f'%integral_angular_error[1], '%.4f'%integral_angular_error[2])
          print('angular_error: ', '%.4f'%angular_error[0], '%.4f'%angular_error[1], '%.4f'%angular_error[2])
          print('angular_error_dot: ', '%.4f'%angular_error_dot[0], '%.4f'%angular_error_dot[1], '%.4f'%angular_error_dot[2])
          
          
          # print('z - z_ref: ', pos_pixhawk_LOC_to_GLOB_NED.z - z_ref)
          print('Z_onboard: ', '%.4f'%pos_pixhawk_LOC_to_GLOB_NED.z)
          # print('(G_acc - controller_z_output)*mass_total: ', (G_acc + controller_z_output)*mass_total)
          print('Thrust T: ', '%.4f'%T[0], '%.4f'%T[1], '%.4f'%T[2], '%.4f'%T[3], '%.4f'%T[4], '%.4f'%T[5], '%.4f'%T[6], '%.4f'%T[7])
          print('Total thrust: ', '%4f'%np.sum(T))
          print('Total torque around Z_onboard: ', '%.4f'%torque_total)
          # print('Pixhawk Euler 321 angles [rad]: ', chvector_to_list(pixhawk_euler))
          
          print('Pixhawk Euler 321 angles [deg]: ', pixhawk_euler_deg_trunc)
          # print('Pixhawk LOCAL angular velocity [rad/s]: ', Wvel_pixhawk_LOC)
          # print('Pixhawk GLOBAL angular velocity [rad/s]: ', Wvel_pixhawk_GLOB)
          
          
          # print('Pixhawk Euler 321 angles OPPOSITE [deg]: ', pixhawk_euler_opposite_deg_trunc)
          # print('Controllers U1 U2 U3 U4:', ' '.join([f'{u:.4f}' for u in U]))
          print('Controllers U1 U2 U3 U4: ', '%.4f'%U[0], '%.4f'%U[1], '%.4f'%U[2], '%.4f'%U[3])
          
          print('mu: ', '%.4f'%mu_x, '%.4f'%mu_y, '%.4f'%mu_z)
          
          # print ('Roll reference [rad]: ', roll_ref)
          # print ('Pitch reference [rad]: ', pitch_ref)
          # print ('Yaw reference [rad]: ', yaw_ref)
          
          print ('Roll reference [deg]: ', '%.4f'%np.rad2deg(roll_ref))
          print ('Pitch reference [deg]: ', '%.4f'%np.rad2deg(pitch_ref))
          print ('Yaw reference [deg]: ', '%.4f'%np.rad2deg(yaw_ref))
          
          print ('mu_PD_baseline_tran [norm x y z]: ', '%.4f'%LA.norm(mu_PD_baseline_tran), '%.4f'%mu_PD_baseline_tran[0].item(), '%.4f'%mu_PD_baseline_tran[1].item(), '%.4f'%mu_PD_baseline_tran[2].item())
          print ('mu_baseline_tran [norm x y z]: ', '%.4f'%LA.norm(mu_baseline_tran), '%.4f'%mu_baseline_tran[0].item(), '%.4f'%mu_baseline_tran[1].item(), '%.4f'%mu_baseline_tran[2].item())
          print ('mu_adaptive_tran [norm x y z]: ', '%.4f'%LA.norm(mu_adaptive_tran), '%.4f'%mu_adaptive_tran[0].item(), '%.4f'%mu_adaptive_tran[1].item(), '%.4f'%mu_adaptive_tran[2].item())
          print ('Moment_baseline_PI [norm x y z]: ', '%.4f'%LA.norm(Moment_baseline_PI), '%.4f'%Moment_baseline_PI[0].item(), '%.4f'%Moment_baseline_PI[1].item(), '%.4f'%Moment_baseline_PI[2].item())
          print ('Moment_baseline [norm x y z]: ', '%.4f'%LA.norm(Moment_baseline), '%.4f'%Moment_baseline[0].item(), '%.4f'%Moment_baseline[1].item(), '%.4f'%Moment_baseline[2].item())
          print ('Moment_adaptive [norm x y z]: ', '%.4f'%LA.norm(Moment_adaptive), '%.4f'%Moment_adaptive[0].item(), '%.4f'%Moment_adaptive[1].item(), '%.4f'%Moment_adaptive[2].item())
          
          print('Time the simulation is taking: ', '%.4f'%simulation_time)
          
          # print('Accumulated force: ', my_frame.Get_accumulated_force()) 
          # print('Aerodynamic force: ', '%.4f'%aerodynamic_force[0].item(), '%.4f'%aerodynamic_force[1].item(), '%.4f'%aerodynamic_force[2].item())
          
          #$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
          
          # print('Ball 3 Euler 321 angles [deg]: ', ball3_euler_deg_trunc)
          # print('Ball 3 Rotmat: ', chmatrix33_to_list(ball3_rotmat))
          
          # print('omega: ', omega)
          
          # print('Drone Frame Position: ', my_frame_pos)
          # print('Pixhawk Coordinate: ', chcoordsys_to_list(coord_pixhawk_GLOB)[0],'\n') # '\n' prints in a new line
                  
          
          # print('Pixhawk LOCAL Position: ', chvector_to_list(pos_pixhawk_LOC))
          print('Pixhawk GLOBAL Position: ', '%.4f'%chcoordsys_to_list(coord_pixhawk_GLOB)[0][0],
                                             '%.4f'%chcoordsys_to_list(coord_pixhawk_GLOB)[0][1],
                                             '%.4f'%chcoordsys_to_list(coord_pixhawk_GLOB)[0][2])
          # print('Pixhawk GLOBAL Velocity: ', chcoordsys_to_list(coord_dt_pixhawk_GLOB)[0])
          # print('Pixhawk LOCAL  Velocity_T: ', chvector_to_list(vel_pixhawk_LOC_T))
          # print('Pixhawk LOCAL  Velocity: ', chvector_to_list(vel_pixhawk_LOC))
          print('Pixhawk GLOBAL Velocity NORM: ', '%.4f'%LA.norm(np.asarray(chcoordsys_to_list(coord_dt_pixhawk_GLOB)[0])))
          # print('Pixhawk LOCAL Velocity_T NORM: ', LA.norm(np.asarray(chvector_to_list(vel_pixhawk_LOC_T))))
          # print('Pixhawk LOCAL Velocity NORM: ', LA.norm(np.asarray(chvector_to_list(vel_pixhawk_LOC))),'\n')
          
          # print('Pixhawk Acceleration: ', chcoordsys_to_list(coord_dtdt_pixhawk_GLOB)[0])
          # print('Pixhawk Angular Velocity: ', chvector_to_list(Wvel_pixhawk_GLOB))
          # print('Pixhawk Angular Acceleration: ', chvector_to_list(Wacc_pixhawk_GLOB))
          
          # print('Drone Frame Position: ', chvector_to_list(my_frame_pos))
          
          # print('Ball_1 Position: ', my_ball1_pos)
          # print('Ball_1 Position seen from the Box Ref. Sys.: ', my_ball1_pos_box)
          
          # print('Ball_3 GLOBAL Velocity: ', chcoordsys_to_list(my_ball3.GetCoord_dt())[0])
          # print('Ball_3 LOCAL Velocity: ', chvector_to_list(coord_dt_ball3_LOC),'\n')
          # print('Ball_3 Quaternion: ', chcoordsys_to_list(my_ball3.GetCoord())[1],'\n')
          # print('Ball_3 Euler 321 angles: ', chvector_to_list(euler321_fromQ_asChVector(my_ball3.GetCoord().rot)),'\n')
          # print('Ball_3 Euler 123 angles: ', chvector_to_list(my_ball3.GetCoord().rot.Q_to_Euler123()),'\n')
          
          # print('COG Position: ', chvector_to_list(COG_total))
          
          
          # my_ball1_cfr = my_ball1.GetContactForce() # contact force applied to ball 1
          # print('Contact Force Ball_1: ', my_ball1_cfr)
          
          # my_ball2_cfr = my_ball2.GetContactForce()
          # my_ball_cfr_list.append([time_now, chvector_to_list(my_ball1_cfr)[0], chvector_to_list(my_ball1_cfr)[1], chvector_to_list(my_ball1_cfr)[2],chvector_to_list(my_ball2_cfr)[0], chvector_to_list(my_ball2_cfr)[1], chvector_to_list(my_ball2_cfr)[2]])
          # print('Contact Force Ball_2: ', my_ball2_cfr)
          
          # my_box_cfr = my_box.GetContactForce()
          # print('Contact Force Box: ', my_box_cfr)
          
          # my_frame_cfr = my_frame.GetContactForce()
          # print('Contact Force Drone Frame: ', my_box_cfr, '\n')
          
          # my_ball1_ctr = my_ball1.GetContactTorque() # contact torque applied to ball 1
          # print('Contact Torque Ball_1: ', my_ball1_ctr)
          
          # my_ball2_ctr = my_ball2.GetContactTorque()
          # print('Contact Torque Ball_2: ', my_ball2_ctr)
          
          # my_box_ctr = my_box.GetContactTorque()
          # print('Contact Torque Box: ', my_box_ctr)
          
          # my_frame_ctr = my_frame.GetContactTorque()
          # print('Contact Torque Drone Frame: ', my_box_ctr, '\n')
    #if Wrapper_execution == True:
     #   DATA = DATA.T
        #with open(csv_file_path, mode='a', newline='') as csv_file_wrapper:
        #    csv_writer = csv.writer(csv_file_wrapper)
        #    csv_writer.writerow(["Time","Sum", "Average","Product","Maximum","Minimum"])
         #   csv_writer.writerows(DATA)                   
      #  with open("logfile","a",newline='') as f:
       #     f.write(DATA)
        #    if f.tell()==0:
         #       f.write(header_csv)
    if Wrapper_execution == True:
        DATA = DATA.T  # Transpose the matrix if necessary to get the correct format
        
        # Open the CSV file in append mode
        with open("logfile.log", mode='a', newline='') as f:
            csv_writer = csv.writer(f)
            
            # Write header if the file is empty (f.tell() == 0)
            if f.tell() == 0:
                csv_writer.writerow(header_csv)  # Write the header row
            
            # Write the data rows
            for row in DATA:
                csv_writer.writerow(row)  # Write each row of data
    
    #%% Plots and Post-processing
    
    # state_pixhawk_GLOB_array = list_to_array(state_pixhawk_GLOB)
    # my_ball_cfr_array = list_to_array(my_ball_cfr_list)
    
    # # Use matplotlib to plot data
    # plt.plot(times, euler, color='red') #plot the data 
    # plt.ylabel('Pitch [rad]') #set the label for y axis
    # plt.xlabel('time [s]') #set the label for x-axis
    # plt.title("Ball3 rotation angle") #set the title of the graph
    # plt.show() #display the graph
    
    # # Use matplotlib to plot data
    # plt.plot(times, my_ball_cfr_array[:,1],'o-', color='red', label='X Contact Force') #plot the data 
    # plt.plot(times, my_ball_cfr_array[:,2],'o-', color='green', label='Y Contact Force') #plot the data 
    # plt.plot(times, my_ball_cfr_array[:,3],'o-', color='blue', label='Z Contact Force') #plot the data 
    # plt.legend()
    # plt.ylabel('Contact Force [N]') #set the label for y axis
    # plt.xlabel('time [s]') #set the label for x-axis
    # plt.title("Ball1 Contact Force") #set the title of the graph
    # plt.show() #display the graph     
    
    # # Use matplotlib to plot data
    # plt.plot(times, state_pixhawk_GLOB_array[:,1], color='red') #plot the data 
    # plt.ylabel('Pixhawk x [m]') #set the label for y axis
    # plt.xlabel('time [s]') #set the label for x-axis
    # plt.title("Pixhawk x position") #set the title of the graph
    # plt.show() #display the graph   
            
    if Wrapper_execution == False:
        # DATA saved in CSV file
        np.savetxt("DATA_" + controller_type + ".csv", 
                    DATA,
                    delimiter =", ",  
                    fmt ='% s')
        
  